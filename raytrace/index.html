
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - render-to-texture</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #111111;
				font-family:Monospace;
				font-size:13px;
				text-align:center;
				font-weight: bold;
				background-color: #111111;
				margin: 0px;
				overflow: hidden;
			}

			#info {
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
			}

			a {
				color: #ffffff;
			}

		</style>
	</head>
	<body>

		<div id="container"></div>
		<div id="info"><a href="http://threejs.org" target="_blank">three.js</a> render-to-texture webgl example</div>

		<script src="build/three.min.js"></script>
		<script src="js/Detector.js"></script>
		<script src="js/libs/stats.min.js"></script>
		<script src="js/controls/FirstPersonControls.js"></script>
		<script src="js/controls/TrackballControls.js"></script>
		<script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>

		<!--***FRAGMENT SHADER TEXTURE***-->				      
		<script id="fragment_shader_texture" type="x-shader/x-fragment">
			precision mediump float;
			
			varying vec3 vPosition;
			varying vec2 vUv;
  			uniform vec3 cameraPos;
			uniform int numPhotons[8];
			uniform int index;
			uniform float texWidth;
			//const int cIndex = index;
			
			//samplers
			uniform sampler2D tDir;
			uniform sampler2D tPos;
			uniform sampler2D tPwr;
			
			const vec3 ambientLight = vec3(0.3, 0.3, 0.3);				
			const int NUM_LIGHTS = 1;
			const int NUM_SPHERES = 1;
			int currentShape = -1;
			float epsilon = 0.0001;

			//lights
			struct PointLight
			{
				vec3 pos;
				vec3 col;
			};
			uniform PointLight lights[NUM_LIGHTS];

			//cube info
			vec3 cubeMin = vec3(-1.0, -1.0, -1.0);
			vec3 cubeMax = vec3(1.0, 1.0, 1.0);

			//spheres
			struct Sphere
			{
				vec3 pos;
				vec3 diffuse;				
				float reflectance;
				float transparency;
			};
			uniform Sphere spheres[NUM_SPHERES];
			
			bool intersectCube(vec3 rStart, vec3 rDir, vec3 vMin, vec3 vMax, out float dist)
			{
				//dist = 10000.0;
				vec3 tMin = (vMin - rStart) / rDir;
				vec3 tMax = (vMax - rStart) / rDir;

				vec3 t1 = min(tMin, tMax);
				vec3 t2 = max(tMin, tMax);
				float tNear = max(max(t1.x, t1.y), t1.z);
				float tFar = min(min(t2.x, t2.y), t2.z);

				if(tNear < tFar)//make sure intersect along positive ray direction
				{					
					dist = tFar;
					return true;
				}
				
				return false;
			}
			
			bool intersectSphere(vec3 pos, vec3 rStart, vec3 rDir, out float dist)
			{
				vec3 c = pos - rStart;
				float b = dot(rDir, c);
				float d = b*b - dot(c, c) + 0.125;
				if (d < 0.0) {
  					dist = 10000.0;
  					return false;
				}

    			float t1 = b - sqrt(d);
				//float t2 = b + sqrt(d);
				
				if (t1 < 0.0) {
					return false;
				}
				dist = t1;
				return true;
  			}		
			
			bool intersectScene(vec3 rStart, vec3 rDir, out vec3 pos)
			{
				float d = 10000.0;
				float newD;
				bool hit = false;
				
				if (intersectCube(rStart, rDir, cubeMin, cubeMax, newD))
				{
					hit = true;
					if(newD < d)
					{
						d = newD;
						currentShape = 0;
					}
					
				}
				
				for (int i = 0; i < NUM_SPHERES; i++)
				{
					if (intersectSphere(spheres[i].pos, rStart, rDir, newD))
					{
						hit = true;
						if (newD < d) {
							d = newD;
							currentShape = (i+1);
						}
					}	
				}
				if (hit)
				{
					pos = rStart + d * rDir;
				}				
				return hit;
			}
			
			//shadow ray shooter
			float intersectScene(vec3 rStart, vec3 rDir)
			{
				float d = 10000.0;
				float newD;				
				
				if(intersectCube(rStart, rDir, cubeMin, cubeMax, newD))
				{
					if(newD < d)
					{
						d = newD;
					}
				}

		
				for (int i = 0; i < NUM_SPHERES; i++)
				{
					if (intersectSphere(spheres[i].pos, rStart, rDir, newD))
					{
						if (newD < d)
						{
							d = newD;
						}
					}	
				}
				
				return d;
			}
		
			//calc lighting
			vec3 colorAt(vec3 c, vec3 pos, vec3 n)
			{
				vec3 color = vec3(0.0, 0.0, 0.0);
				
				for (int i = 0; i < 1; i++) 
				{					
					vec3 lDir = (lights[i].pos - pos);
					float dist = length(lDir);					
					lDir = normalize(lDir);
					float lamb = dot(n, lDir);					

					//cull possible intersections if normals in diff dir's
					if ( lamb <= 0.0 )
					{
						continue;
					}
					//if position obstructed from light
					if(intersectScene((pos + .01*n), lDir) < dist)
					{
						continue;
					}			
					
					//calc color					
					color += c * lights[i].col * lamb;
				}
				//add ambient light			
				color += ambientLight * c;
				return color;
			}
			
			vec3 refrDir(float n1, float n2, vec3 norm, vec3 i)
			{
				float n = n1/n2;
				float cosI = dot(-i, norm);
				float sin2T = n * n * ( 1.0 - cosI * cosI);
				if (sin2T > 1.0)//total internal reflection
				{
					return vec3(0.0, 0.0, 0.0);
				}
				float cosT = sqrt(1.0 - sin2T);
				return n * i + (n * cosI - cosT) * norm;
			}
			
			float fresnel(float n1, float n2, vec3 norm, vec3 i)//schlick's approx
			{
				float ref = (n1-n2)/(n1+n2);
				ref *= ref;
				float cosX = dot(-i, norm);
				if (n1 > n2)
				{
					float n = n1/n2;
					float sin2T = n * n * (1.0-cosX * cosX);
					if (sin2T > 1.0)
					{
						return 1.0;
					}
					cosX = sqrt(1.0-sin2T);
				}
				float x = 1.0-cosX;
				return ref + (1.0-ref) * x * x * x * x * x;
			}

			vec3 cubeNormal(vec3 p, vec3 cMin, vec3 cMax)
			{

					 if(p.x < (cMin.x + epsilon)) return vec3(-1.0, 0.0, 0.0);
				else if(p.x > (cMax.x - epsilon)) return vec3(1.0, 0.0, 0.0);
				else if(p.y < (cMin.y + epsilon)) return vec3(0.0, -1.0, 0.0);
				else if(p.y > (cMax.y - epsilon)) return vec3(0.0, 1.0,  0.0);
				else if(p.z < (cMin.z + epsilon)) return vec3(0.0, 0.0, -1.0);
				else return vec3(0.0, 0.0, 1.0);
			}

			vec3 cubeColor(vec3 p)
			{				
				if(p.x < (cubeMin.x + epsilon)) return vec3(0.15, 0.48, 0.09);//left
				else if(p.x > (cubeMax.x - epsilon)) return vec3(0.63, 0.06, 0.04);//right
				else if(p.y < (cubeMin.y + epsilon)) return vec3(0.76, 0.75, 0.5);//bottom
				else if(p.y > (cubeMax.y - epsilon)) return vec3(0.76, 0.75, 0.5);//top
				else if(p.z < (cubeMin.z + epsilon)) return vec3(0.76, 0.75, 0.5);//back
				else return vec3(0.76, 0.75, 0.5);//front
			}
			
			vec3 getColor(int shape, vec3 pos, out vec3 norm)
			{
				vec3 n, c;
				if(shape == 0)//cube
				{
					n = -cubeNormal(pos, cubeMin, cubeMax);
					c = cubeColor(pos);
				}
				else if(shape > 0)//spheres
				{
					for(int i = 0; i < NUM_SPHERES; i++)
					{
						if(shape == (i+1))
						{
							n = normalize(pos - spheres[i].pos);
							c = spheres[i].diffuse;
						}
					}
				}
				else
				{
					norm = vec3(0.0, 0.0, 0.0);
					return norm;
				}

				norm = n;
				return colorAt(c, pos, n);
			}
			
			void cubeSideNormal(vec3 p, out int cSide, out vec3 norm)
			{

				if(p.x < (cubeMin.x + epsilon))//left
				{
					cSide = 2;
					norm = vec3(-1.0, 0.0, 0.0);
					//return {x: -1.0, y: 0.0, z: 0.0};
				}
				else if(p.x > (cubeMin.x - epsilon))//right
				{
					cSide = 3;
					norm = vec3(1.0, 0.0, 0.0);
					//return {x:1.0, y:0.0, z:0.0};
				}
				else if(p.y < (cubeMin.y + epsilon))//bottom
				{
					cSide = 1;
					norm = vec3(0.0, -1.0, 0.0);
					//return {x:0.0, y:-1.0, z:0.0};
				}
				else if(p.y > (cubeMin.y - epsilon))//top
				{
					cSide = 0;
					norm = vec3(0.0, 1.0, 0.0);
					//return {x:0.0, y:1.0, z:0.0};
				}
				else if(p.z < (cubeMin.z + epsilon))//back
				{
					cSide = 5;
					norm = vec3(0.0, 0.0, -1.0);
					//return {x:0.0, y:0.0, z:-1.0};
				}
				else//front
				{
					norm = vec3(0.0, 0.0, 1.0);
					cSide = 4;
					//return {x:0.0, y:0.0, z:1.0};
				}
			}
			
			//gatech
			bool gatedSqDist(vec3 a, vec3 b, float sqradius){ //Gated Squared Distance
				float c = a.x - b.x;          //Efficient When Determining if Thousands of Points
				float d = c*c;                  //Are Within a Radius of a Point (and Most Are Not!)
				if (d > sqradius) return false; //Gate 1 - If this dimension alone is larger than
				c = a.y - b.y;                //         the search radius, no need to continue
				d += c*c;
				if (d > sqradius) return false; //Gate 2
				c = a.z - b.z;
				d += c*c;
				if (d > sqradius) return false; //Gate 3
				//gSqDist = d;
				return true ; //Store Squared Distance Itself in Global State
			}

			
  			void main(void)
  			{
  				//calc ray dir
				vec3 cameraDir = normalize(vPosition - cameraPos);

				//determine intersect
				vec3 sP;
				bool hit = false;				
				hit = intersectScene(cameraPos, cameraDir, sP);
				
				int texShape;
				float texShapeIndex;
				int cSide;
				vec3 norm;
				
				/*if(hit)
				{
					//get shape hit and normal					
					if (currentShape == 0)
					{
						cubeSideNormal(sP, cSide, norm);//set cube normal & side
						texShape = cSide;
					}
					else
					{
						for(int i = 0; i < NUM_SPHERES; i++)
						{
							if(currentShape == (i+1))
							{
								norm = sP - spheres[i].pos;
							}							
						}						
						texShape = currentShape+5;
					}
					
					//find closest 10 photons w/in sq rad 0.7
					texShapeIndex = (8.0-(float(texShape)+1.0))/8.0;
					
					int photonsFound = 0;
					vec3 accumColor = vec3(0.0, 0.0, 0.0);
					vec3 tCol;
					for(int i = 0; i < 1024; i++ )
					{
						if(photonsFound > 1) break; 						
						float photon = float(i)/texWidth;
						//get position
						vec3 photonPos = vec3(texture2D(tPos, vec2(photon, texShapeIndex)));
						//rescale vals
						photonPos *= 255.0;
						photonPos -= 127.0;
						photonPos = normalize(photonPos);
						
						if(photonPos.x == 0.0 && photonPos.y == 0.0 && photonPos.z == 0.0) break;
						if(gatedSqDist(sP, photonPos, 2.0))
						{
							photonsFound++;
							//get dir & pwr
							vec3 photonDir = vec3(texture2D(tDir, vec2(photon, texShapeIndex)));
							vec3 photonPwr = vec3(texture2D(tPwr, vec2(photon, texShapeIndex)));
							//rescale vals
							photonDir *= 255.0;
							photonDir -= 127.0;
							photonDir = normalize(photonDir);
							
							
							//accumColor += dot(photonDir, norm)*photonPwr;
							accumColor = vec3(0.0, 1.0, 0.0);
							//tCol = dot(photonDir, norm);
							//tCol = photonPwr*dot(photonDir, norm)*200.0;
							//break;
						}
					}
					gl_FragColor = vec4(accumColor, 1.0);
					//gl_FragColor = vec4(tCol, 1.0);
				}
				else
				{
					gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
				}*/
				
				/*if (hit)
				{					
					vec3 sN, sC = vec3(0.0, 0.0, 0.0), reflC = vec3(0.0, 0.0,0.0), refrC = vec3(0.0, 0.0, 0.0);
					sC = getColor(currentShape, sP, sN);
					
					for(int i = 0; i < NUM_SPHERES; i++)
					{
						if(currentShape == (i+1))
						{
							//reflective sphere
							if(spheres[i].reflectance > 0.0)
							{
								//store current shape
								int tempShape = currentShape;
								vec3 rN, reflP, reflD = reflect(cameraDir, sN);
								if(intersectScene(sP + 0.01*sN, reflD, reflP))
								{
									reflC = getColor(currentShape, reflP, rN);
									sC = reflC*spheres[i].reflectance;
								}
								currentShape = tempShape;
							}
							//transparent sphere
							if(spheres[i].transparency > 0.0)
							{
								vec3 refrD, refrP;
								//get refraction dir
								refrD = refrDir(1.0, 1.33, sN, cameraDir);

								//store current shape
								int tempShape = currentShape;
								if(intersectScene(sP - 0.01*sN, refrD, refrP))
								{
									//get normal
									vec3 rN = -(refrP - spheres[i].pos);//getcolor() vs calculating directly? which faster

									//second refraction
									refrD = refrDir(1.0, 1.33, rN, cameraDir);

									//store current shape
									int tempShape = currentShape;
									if(intersectScene(refrP - 0.01*rN, refrD, refrP))
									{
										refrC = getColor(currentShape, refrP, rN);
										//mix reflective & refr colors if both enabled
										if(spheres[i].reflectance > 0.0)
										{
											float f = fresnel(1.0, 1.33, sN, cameraDir);
											sC = (f*reflC*spheres[i].reflectance + (1.0-f)*refrC*spheres[i].transparency) + sC;
										}
										else
										{
											sC = (1.0-spheres[i].transparency)*refrC;
										}										
									}
									currentShape = tempShape;
								}
								currentShape = tempShape;
							}
						}
					}			
					
					
					//float fresnel(float n1, float n2, vec3 norm, vec3 i)//schlick's approx
					//float f = fresnel(1.0, 1.33, sN, cameraDir);
					//vec3 finalC = (f*reflC*surfShape.reflectance + (1.0-f)*refrC*surfShape.transparency) + surfC;
					//currentShape = -1;
					//gl_FragColor = vec4(refrC, 1.0);
					gl_FragColor = vec4(sC, 1.0);
					//gl_FragColor = texture2D(tPwr, vec2(0.1,0.1));
					//gl_FragColor = vec4(255.0, 255.0, 255.0,1.0);
				}
				else
				{
      					gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
				}*/
				
				//gl_FragColor = texture2D(tDir, vUv);
				//gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
				//gl_FragColor = texture2D(tDir, vec2((6.0/128.0), 0.125));
 			}
		</script>
		
		<!--***VERTEX SHADER TEXTURE***-->
		<script id="vertex_shader_texture" type="x-shader/x-vertex">

			attribute vec3 aPlotPosition;

			varying vec3 vPosition;
			varying vec2 vUv;

			void main() {
				vUv = uv;
				vPosition =  aPlotPosition;
				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			}

		</script>

		<!--***FRAGMENT SHADER SCREEN***-->
		<script id="fragment_shader_screen" type="x-shader/x-fragment">

			varying vec2 vUv;

			uniform sampler2D tDiffuse;

			void main() {
				gl_FragColor = texture2D( tDiffuse, vUv );
			}

		</script>

		<!--***VERTEX SHADER SCREEN***-->
		<script id="vertex_shader_screen" type="x-shader/x-vertex">

			varying vec2 vUv;

			void main() {
				vUv = uv;
				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			}

		</script>

		<script>

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			//cam stuff
			var rtTexture, material, quad;
			var container, stats;
			var cameraRTT, sceneRTT, sceneScreen, renderer, scene, camera;
			var uniforms, attributes, controls;
			var ratio = 1.6
			var w = 3.2;
			var h = 2;			
			var camOffset = -.5;
			
			var lookDir; 			
			var origin;
			var up;
			var center;			
			var plotPos;
			var attributes;			

			//-------------------------------------------------------------------------------------//
			//cube info
			//-------------------------------------------------------------------------------------//			
			var cubeMin = {x:-1.0, y:-1.0, z:-1.0};
			var cubeMax = {x: 1.0, y: 1.0, z: 1.0};

			//-------------------------------------------------------------------------------------//
			//Sphere obj
			//-------------------------------------------------------------------------------------//
			var NUM_SPHERES = 1;
			function Sphere(pos, diffuse, reflectance, transparency)
			{
				this.pos = pos;
				this.diffuse = diffuse;
				this.reflectance = reflectance;
				this.transparency = transparency;
			}
			var spheres = [];

			var s1Pos = {x: 0, y: 0, z:0};
			var s1Diffuse = {x: 0.76, y: 0.75, z:0.5};
			var s1Refl = 0;
			var s1Transp = 0;

			spheres[0] = new Sphere(s1Pos, s1Diffuse, s1Refl, s1Transp);

			//-------------------------------------------------------------------------------------//
			//Light obj
			//-------------------------------------------------------------------------------------//

			function PointLight(pos, col)
			{
				this.pos = pos;
				this.col = col;
			}
			var lights = [];

			var l1Pos = {x: 0, y: 0.8, z:0};
			var l1Col = {x: 1, y: 1, z:1};

			//-------------------------------------------------------------------------------------//
			//Photon Mapping
			//-------------------------------------------------------------------------------------//			
			//texture globals
			var tW = 1024, tH = 8, depth = 3; // texture dims
			var size = tW*tH*depth;
			//texture arrays
			var posTexArray = new Uint8Array(size), dirTexArray = new Uint8Array(size), pwrTexArray = new Uint8Array(size);
			var posTex, dirTex, pwrTex;
			var posViz = [], dirViz = [], pwrViz = [];
			//--store # photons on each shape
			var TOP = 0, BOTTOM = 1, RIGHT = 2, LEFT = 3, FRONT = 4, BACK = 5, SPHERE1 = 6;//array indices
			var numberPhotons = [0, 0, 0, 0, 0, 0, 0];
			
			//photon globals
			var NUM_PHOTONS = 1000;
			var maxBounces = 3;		
			var powerScale = 1;
			
			//--photon fate
			var DIFFUSE = 0, ABSORB = 1, TRANSMIT = 2, fate = -1;
			
			//--photon components
			var pDir, pPos, pPwr;
			var shadowPwr = {x: 0, y: 0, z: 0};

			//intersection globals
			var currentShape = -1, cSide = -1;
			var shapeDiffuse, norm, epsilon = 0.01, hitPos, dist;

			//scatter n photons in scene & store in arrays for upload to textures
			function scatterPhotons(n)
			{			
				var hit = false;
				pPwr = vDivide(l1Col, 50);

				for(var i = 0; i < n; i++)
				{
					var bounces = 1;

					//gen rand dir
					pDir = rand3();
					
					//starting pos is light source
					pPos = vCopy(l1Pos);
					
					//while photon has intersected something and hasn't bounced 3 times
					while(bounces <= maxBounces)//add caustics later
					{	
						//intersect with scene
						var nDir = normalize(pDir);
						/*if (typeof nDir === undefined || typeof pos === undefined)
						{
							alert("ndir undefined");
						}
						console.log("nDir: %O", nDir);*/
						hit = intersectScene(pPos, nDir);
						
						if(hit)
						{
							//det shape diffuse
							if(currentShape == 0)//if cube
							{
								norm = vectMul(cubeSideNormal(hitPos, cubeMin, cubeMax), -1);
								shapeDiffuse = cubeColor(hitPos);
								roulette(shapeDiffuse, 0);
							}
							else if(currentShape > 0) // if sphere
							{
								norm = normalize(vectSub(hitPos, spheres[currentShape-1].pos));
								shapeDiffuse = spheres[currentShape-1].diffuse;
								roulette(shapeDiffuse, spheres[currentShape-1].transparency);

								//compute shadow photon
								//--save current intersection info								
								var tShape = currentShape, tPos = hitPos, tDist = dist;

								//--two more intersects
								/*var newPos = vectAdd(hitPos, vectMul(nDir, epsilon));
								if(intersectScene(newPos, nDir))//hit sphere backside
								{
									newPos = vectAdd(hitPos, vectMul(nDir, epsilon));
									if(intersectScene(newPos, nDir))//hit outside sphere
									{
										//store shadow photon - ?how to store shadow
										//storePhoton(hitPos, pDir, shadowPwr, );
										if (currentShape == 0)
										{
											storePhoton(pPos, pDir, shadowPwr, cSide);
										}
										else
										{
											storePhoton(pPos, pDir, shadowPwr, (currentShape+5));
										}	
									}
								}*/

								//--restore inters info
								currentShape = tShape;
								hitPos = tPos;
								dist = tDist;								
							}
							else
							{
								alert("What the fuk!!");
							}


							if(fate == DIFFUSE)//diffusely reflected
							{								
								//get shape & store
								if (currentShape == 0)
								{
									storePhoton(pPos, pDir, pPwr, cSide);
								}
								else
								{
									storePhoton(pPos, pDir, pPwr, (currentShape+5));
								}							

								addViz(hitPos, nDir, pPwr);
								
								//scale photon power
								pPwr = vMultComponent(pPwr, shapeDiffuse);
								pPwr = vDivide(pPwr,powerScale);
								//pPwr = vectMul(pPwr, 100);/*scaling up pwr*/
								
								//reflect photon & adjust slightly
								nDir = reflect(pDir, norm);
								pPos = vectAdd(hitPos, vectMul(nDir,epsilon));
								pDir = vCopy(nDir);
							}
							else if(fate == TRANSMIT && currentShape != 0)//cube cant transmit
							{
								//refract photon 
								//refrDir(n1, n2, norm, i)
								nDir = refrDir(1.0, 1.33, norm, nDir);
								
								//--refract into sphere
								if(intersectScene(vectAdd(hitPos, vectMul(norm, -epsilon), nDir)))
								{
									//--refract outside of sphere
									if (intersectScene(vectAdd(hitPos, vectMul(norm, -epsilon), nDir)))
									{
										hitPos = vectAdd(hitPos, vectMul(norm, epsilon));//adjust slightly
									}
								}								
								else
								{
									break;
								}
							}
							else //absorbed
							{
								addViz(hitPos, nDir, pPwr);
								//get shape & store
								if (currentShape == 0)
								{
									storePhoton(pPos, pDir, pPwr, cSide);
								}
								else
								{
									storePhoton(pPos, pDir, pPwr, (currentShape+5));
								}
								bounces = maxBounces;
							}
							//pPos = vCopy(hitPos);
							bounces++;							
						}
					}
				}
			}
			
			function addViz(pos, dir, pwr)
			{
				posViz.push(pos);
				dirViz.push(dir);
				pwrViz.push(pwr);
			}
			
			function buildTextures()
			{
				posTex = new THREE.DataTexture(posTexArray, tW, tH, THREE.RGBFormat );
				dirTex = new THREE.DataTexture(dirTexArray, tW, tH, THREE.RGBFormat );
				pwrTex = new THREE.DataTexture(pwrTexArray, tW, tH, THREE.RGBFormat );
				
				posTex.needsUpdate = true;
				dirTex.needsUpdate = true;
				pwrTex.needsUpdate = true;
			}

			//determine fate of photon
			function roulette(d, t)//diffuse component, and transmission prob
			{
				var pRefl = vMax(d);
				
				//ensure (pRefl+t <=1)
				if ((pRefl + t) > 1) {
					t = 1-pRefl;
				}
				
				//det photon fate
				//--diff [0, pDifRefl]
				//--transm [pDifRefl, pDifRefl+t]
				//--absorb [pDifRefl, 1]
				var x = Math.random();
				
				if(x < pRefl)
				{
					powerScale = pRefl;
					fate = DIFFUSE;
				}
				else if (x < pRefl+t)
				{
					fate = TRANSMIT;
					alert("transmit");
				}
				else
				{
					fate = ABSORB;
				}
			}
			

			//store photon for shape in tex array
			function storePhoton(pos, dir, pwr, shape)
			{
				var index = shape*tW*depth + numberPhotons[shape]*depth;

				//adj values to 0-255 range b4 storing
				posTexArray[index] = pos.x*127+127;
				posTexArray[index+1] = pos.y*127+127;
				posTexArray[index+2] = pos.z*127+127;

				dirTexArray[index] = dir.x*127+127;
				dirTexArray[index+1] = dir.y*127+127;
				dirTexArray[index+2] = dir.z*127+127;

				pwrTexArray[index] = pwr.x*255;
				pwrTexArray[index+1] = pwr.y*255;
				pwrTexArray[index+2] = pwr.z*255;
				
				//increment #photons on surface
				numberPhotons[shape]++;
			}
			
			function testPhoton() {
				//photon storage
				/*pos1 = {x: 1, y: 2, z: 3};
				dir1 = {x: 4, y: 5, z: 6};
				pwr1 = {x: 7, y: 8, z: 9};
				
				storePhoton(pos1, dir1, pwr1, 0);
				storePhoton(pos1, dir1, pwr1, 0);
				
				storePhoton(pos1, dir1, pwr1, 1);
				storePhoton(pos1, dir1, pwr1, 1);
				
				//russian roulette
				var color = {x:0.76, y:0.75, z:0.5};
				var transp = 0.5;
				
				
				roulette(color, transp);
				
				transp = 0.2;
				roulette(color, transp);*/
				
				//scattering
				//scatterPhotons(100);
				
				/*var dir1 = {x: 4, y: 5, z: 6};
				var dir2;
				dir2 = vCopy(dir1);
				dir1.x = 8;*/
			}

			//-------------------------------------------------------------------------------------//
			//Intersection
			//-------------------------------------------------------------------------------------//	
			function intersectScene(rStart, rDir)
			{
				dist = 10000;
				var d = 10000;
				var hit = false;
				
				if (intersectCube(rStart, rDir, cubeMin, cubeMax))
				{
					hit = true;
					if(dist < d)
					{
						d = dist;
						currentShape = 0;
					}
					
				}
				
				for (var i = 0; i < NUM_SPHERES; i++)
				{
					if (intersectSphere(spheres[i].pos, rStart, rDir))
					{
						hit = true;
						if (dist < d) {
							d = dist;
							currentShape = (i+1);
						}
					}	
				}
				if (hit)
				{
					//hitPos = rStart + d * rDir; //set global pos var
					hitPos = vectAdd(rStart, vectMul(rDir, d));
				}				
				return hit;
			}

			function intersectCube(rStart, rDir, cMin, cMax)
			{
				//var dist = 10000.0;
				//var tMin = (vMin - rStart) / rDir; //-----how would this handle divide by zero????
				//var tMax = (vMax - rStart) / rDir;
				//console.log("rStart: %O", rStart);
				//console.log("rDir: %O", rDir);
				var sub1 = vectSub(cMin, rStart);
				var sub2 = vectSub(cMax, rStart);
				
				/*if (typeof sub1 === undefined || typeof sub2 === undefined)
				{
					alert("undefined");
				}*/
				
				var tMin = vCompDivide(sub1, rDir);
				var tMax = vCompDivide(sub2, rDir);			
				
				var t1 = minComp(tMin, tMax);
				var t2 = maxComp(tMin, tMax);
				var tNear = vMax(t1);
				var tFar = vMin(t2);

				if(tNear < tFar)//make sure intersect along positive ray direction
				{					
					dist = tFar;
					return true;
				}
				
				return false;
			}
			
			/*
			 *	     if(p.x < (cubeMin.x + epsilon)) return vec3(0.63, 0.06, 0.04);//left
				else if(p.x > (cubeMax.x - epsilon)) return vec3(0.15, 0.48, 0.09);//right
				else if(p.y < (cubeMin.y + epsilon)) return vec3(0.0, 1.0, 0.0);//bottom
				else if(p.y > (cubeMax.y - epsilon)) return vec3(0.0, 0.0,  1.0);//top
				else if(p.z < (cubeMin.z + epsilon)) return vec3(0.0, 1.0, 1.0);//back
				else return vec3(0.0, 0.0, 1.0);//front
			 */

			function cubeSideNormal(p, cMin, cMax)
			{

				if(p.x < (cMin.x + epsilon))//left
				{
					cSide = 2;
					return {x: -1.0, y: 0.0, z: 0.0};
				}
				else if(p.x > (cMax.x - epsilon))//right
				{
					cSide = 3;
					return {x:1.0, y:0.0, z:0.0};
				}
				else if(p.y < (cMin.y + epsilon))//bottom
				{
					cSide = 1;
					return {x:0.0, y:-1.0, z:0.0};
				}
				else if(p.y > (cMax.y - epsilon))//top
				{
					cSide = 0;
					return {x:0.0, y:1.0, z:0.0};
				}
				else if(p.z < (cMin.z + epsilon))//back
				{
					cSide = 5;
					return {x:0.0, y:0.0, z:-1.0};
				}
				else//front
				{
					cSide = 4;
					return {x:0.0, y:0.0, z:1.0};
				}
			}

			function cubeColor(p)
			{
				if(p.x > 0.9999)
				{
					return {x:0.63, y:0.06, z:0.04};
				}
				else if(p.x < -0.9999)
				{
					return {x:0.15, y:0.48, z:0.09};
				}
				else
				{
					return {x:0.76, y:0.75, z:0.5};
				}
			}
			
			function intersectSphere(pos, rStart, rDir)
			{
				//vec3 c = pos - rStart;
				//float b = dot(rDir, c);
				//float d = b*b - dot(c, c) + 0.125;
				var c = vectSub(pos, rStart);
				var b = dot(rDir, c);
				var d = b*b-dot(c,c) + 0.125;

				if (d < 0.0) {
  					dist = 10000.0;
  					return false;
				}

				var t1 = b - Math.sqrt(d);
				//float t2 = b + sqrt(d);
				
				if (t1 < 0.0) {
					return false;
				}
				dist = t1;
				return true;
  			}
			
			/*vec3 refrDir(float n1, float n2, vec3 norm, vec3 i)
			{
				float n = n1/n2;
				float cosI = dot(-i, norm);
				float sin2T = n * n * ( 1.0 - cosI * cosI);
				if (sin2T > 1.0)//total internal reflection
				{
					return vec3(0.0, 0.0, 0.0);
				}
				float cosT = sqrt(1.0 - sin2T);
				return n * i + (n * cosI - cosT) * norm;
			}
			*/
			
			function refrDir(n1, n2, norm, i)
			{
				var n = n1/n2;
				var cosI = dot(vectMul(i, -1), norm);
				var sin2T = n * n * ( 1.0 - cosI * cosI);
				if (sin2T > 1.0)//total internal reflection
				{
					return {x: 0, y:0, z:0};
				}
				var cosT = Math.sqrt(1.0 - sin2T);
				return vectAdd(vectMul(i, n), vecMul(norm, (n*cosI - cosT)));
			}

			//I - 2.0 * dot(N, I) * N
			function reflect(i, n)
			{
				return vectSub(i, vectMul(n, 2.0 * dot(n,i)));
			}
			
			function testIntersections()
			{
				/*var n = {x: 0, y: 0, z: 1};
				var v = {x: 1, y: 0, z: -1};
				
				var rflct = reflect(v,n);
				
				var cubeStart = {x: 0, y: 0, z: -1};
				var cubeDir = {x: 1, y: 0, z: 0};
				var cubeHit = intersectCube(cubeStart, cubeDir, cubeMin, cubeMax);
				
				var sphereStart = {x: 0, y: 0, z: -1};
				var sphereDir = {x: 0, y: 0, z: 1};
				var sphereHit = intersectSphere(s1Pos, sphereStart, sphereDir);*/
				
				var cubeStart = {x: 0.8, y: 0.8, z: -1};
				var cubeDir = {x: 0, y: 0, z: 1};
				
				var sphereStart = {x: 0, y: 0, z: -1};
				var sphereDir = {x: 0, y: 0, z: 1};
				
				var sceneHit = intersectScene(sphereStart, sphereDir);
				var sceneHitPos = hitPos;
				var sceneDist = dist;
				
				var sceneHit = intersectScene(cubeStart, cubeDir);
				sceneHitPos = hitPos;
				sceneDist = dist;
				
				//test refraction somehow!!!
			}
			
			/*function buildTextures(plane)
			{
				//scatter photons
				scatterPhotons(NUM_PHOTONS);
				
				//-------------------------------------------------------------------------------------//
				//Diffuse tex's
				//-------------------------------------------------------------------------------------//
				var posMap = new THREE.DataTexture(pos, tW, tH, THREE.RGBFormat );
				posMap.needsUpdate = true;	
				var sampleTexMaterial = new THREE.MeshBasicMaterial({map: posMap});
				var posMesh = new THREE.Mesh( plane, sampleTexMaterial );
				sampleTexScreen = new THREE.Scene();
				sampleTexScreen.add(posMesh);
				
				
				//-------------------------------------------------------------------------------------//
				//Caustic tex's
				//-------------------------------------------------------------------------------------//
			}*/
			var perspCamera, photonScene, photonMat, lines, perspControls, photonColor;
			
			
			function buildGeometry()
			{
				scatterPhotons(100);
				
				//for each shape
				for(var i = 0; i < posViz.length; i++)
				{
					var a = vCopy(posViz[i]);
					var m = vectMul(dirViz[i], .25);
					var b = vectAdd(a, m);
					
					var photonGeom = new THREE.Geometry();
					photonGeom.vertices.push(new THREE.Vector3(a.x, a.y, a.z));
					photonGeom.vertices.push(new THREE.Vector3(b.x, b.y, b.z));
					
					//get photon color
					var r, g, b;
					r = pwrViz[i].x*255*70;
					g = pwrViz[i].y*255*70;
					b = pwrViz[i].z*255*70;
					var col = "rgb(" + Math.floor(r) + "," + Math.floor(g) + "," + Math.floor(b) + ")";
					//var col = "rgb(255,0,0)";
					photonColor = new THREE.Color(col);	
					photonMat = new THREE.LineBasicMaterial({color: photonColor});//{color: "0x0000ff"});
					
					lines = new THREE.Line(photonGeom, photonMat, THREE.LinePieces);
					photonScene.add(lines);
				}
			}
			function initViz()
			{
				//photon viz cam
				perspCamera = new THREE.PerspectiveCamera(45, w / h, 1, 500);
				perspCamera.position.set(0, 0, 5);
				perspCamera.lookAt(new THREE.Vector3(0, 0, 0));
				perspControls = new THREE.TrackballControls( perspCamera, renderer.domElement );		
				//photon vis scene
				photonScene = new THREE.Scene();			
			}
			//-------------------------------------------------------------------------------------//
			//Init 
			//-------------------------------------------------------------------------------------//
			function init() {
				container = document.getElementById( 'container' );

				renderer = new THREE.WebGLRenderer();
				renderer.setSize( 640, 400 );
				renderer.autoClear = false;

				container.appendChild( renderer.domElement );

				lookDir = {x: 0, y: 0, z: 0};
				camUp = {x: 0, y: 1, z: 0};
				origin = {x: 0, y: 0, z: 0};			
				center = {x: 0, y: 0, z: 0};
				
				//photon viz cam
				/*perspCamera = new THREE.PerspectiveCamera(45, w / h, 1, 500);
				perspCamera.position.set(0, 0, 5);
				perspCamera.lookAt(new THREE.Vector3(0, 0, 0));
				perspControls = new THREE.TrackballControls( perspCamera, renderer.domElement );		
				//photon vis scene
				photonScene = new THREE.Scene();
				//line mat
				photonColor = new THREE.Color("rgb(255,0,0)");	
				photonMat = new THREE.LineBasicMaterial(photonColor);//{color: "0x0000ff"});
				photonGeom = new THREE.Geometry();
				
				scatterPhotons(100);
				
				buildGeometry();
				lines = new THREE.Line(photonGeom, photonMat, THREE.LinePieces);
				photonScene.add(lines);*/
				initViz();
				buildGeometry();
				
				
				//camera
				cameraRTT = new THREE.OrthographicCamera( w / - 2, w / 2, h  / 2, h / - 2, -10000, 10000 );
				cameraRTT.position.z = 20;
				
				/*moving camera*/
				camera = new THREE.OrthographicCamera( w / - 2, w / 2, h  / 2, h / - 2, -10000, 10000 );
				camera.position.z = 15;
				
				//controls
				controls = new THREE.TrackballControls( camera, renderer.domElement );

				//scenes
				sceneRTT = new THREE.Scene();
				sceneScreen = new THREE.Scene();

				//txtre to render to
				rtTexture = new THREE.WebGLRenderTarget( 512, 512, { minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter, format: THREE.RGBFormat } );	

				//scatter photons
				//scatterPhotons(100);
				//buildGeometry();
				
				uniforms =
				{
					texWidth:
					{
						type: "f",
						value: tW
					},
					index:
					{
						type: "i",
						value: 3
					},
					//number photons on each shape
					numPhotons:
					{
						type: "iv1",
						value: numberPhotons
					},
					//texture uniforms
					tDir:
					{
						type: "t", value: dirTex
					},
					tPos:
					{
						type: "t", value: posTex
					},
					tPwr:
					{
						type: "t", value: pwrTex
					},					
					//sphere1
					"spheres[0].pos": {
						type: 'fv',
						value: [s1Pos.x, s1Pos.y, s1Pos.z]
					},
					"spheres[0].diffuse": {
						type: 'fv',
						value: [s1Diffuse.x, s1Diffuse.y, s1Diffuse.z]
					},
					"spheres[0].reflectance": {
						type: 'f',
						value: s1Refl
					},					
					"spheres[0].transparency": {
						type: 'f',
						value: s1Transp
					},
					//--lights
					"lights[0].pos": {
						type: 'fv',
						value: [l1Pos.x, l1Pos.y, l1Pos.z]
					},
					"lights[0].col": {
						type: 'fv',
						value: [l1Col.x, l1Col.y, l1Col.z]
					},
					/**********************************************************/
					cameraPos: {
						type: 'fv', // vec3
						value: [0, 0, 0]
					},
				};			

				attributes = {
					aPlotPosition: {
						type : 'v3',
						value : []
					},
				}
				
				plotPos = attributes.aPlotPosition.value;
				for (var i = 0; i < 4; i++) {
					plotPos[i] = 0;
				}

				material = new THREE.ShaderMaterial( {
					uniforms: uniforms,
					attributes: attributes,
					vertexShader: document.getElementById( 'vertex_shader_texture' ).textContent,
					fragmentShader: document.getElementById( 'fragment_shader_texture' ).textContent
				} );

				var materialScreen = new THREE.ShaderMaterial( {
					uniforms: { tDiffuse: { type: "t", value: rtTexture } },
					vertexShader: document.getElementById( 'vertex_shader_screen' ).textContent,
					fragmentShader: document.getElementById( 'fragment_shader_screen' ).textContent,
					depthWrite: false
				} );

				var plane = new THREE.PlaneGeometry( w, h);
				/*--------------------------------------------------------------------------*/
				
				//build textures
				//buildTextures(plane);
				/*var sampleTex, texWidth = 128, texHeight = 8, texDepth = 3;
				var size = texWidth*texHeight*texDepth;
				sampleTex = new Uint8Array(size);
				for(var i = 0; i < size; i++)
				{
					sampleTex[i*3] = 255;
					sampleTex[i*3+1] = 0;
					sampleTex[i*3+2] = 0;
				}
				var texMap = new THREE.DataTexture(sampleTex, texWidth, texHeight, THREE.RGBFormat );
				texMap.needsUpdate = true;	
				var sampleTexMaterial = new THREE.MeshBasicMaterial({map: texMap});
				var texMesh = new THREE.Mesh( plane, sampleTexMaterial );
				sampleTexScreen = new THREE.Scene();
				sampleTexScreen.add(texMesh);*/
				
				//take a look at pos, dir, pwr
				/*var texMap = new THREE.DataTexture(dirTex, tW, tH, THREE.RGBFormat );
				texMap.needsUpdate = true;	
				var sampleTexMaterial = new THREE.MeshBasicMaterial({map: texMap});
				var texMesh = new THREE.Mesh( plane, sampleTexMaterial );
				sampleTexScreen = new THREE.Scene();
				sampleTexScreen.add(texMesh);*/
				/*--------------------------------------------------------------------------*/
				

				quad = new THREE.Mesh( plane, material );
				quad.position.z = 0;
				sceneRTT.add( quad );

				quad = new THREE.Mesh( plane, materialScreen );
				quad.position.z = 0;
				sceneScreen.add( quad );
				
				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				container.appendChild( stats.domElement );
			}

			//-------------------------------------------------------------------------------------//
			//Render
			//-------------------------------------------------------------------------------------//
			function animate() {

				requestAnimationFrame( animate );
				stats.update();
				controls.update();
				perspControls.update();
				render();				
			}						

			//-------------------------------------------------------------------------------------//
			//Animate
			//-------------------------------------------------------------------------------------//
			function render() {
				camera.updateMatrixWorld();
				camera.matrixWorldInverse.getInverse(camera.matrixWorld);			
		
				/*update attributes*/
				//--update 4 corners				
   				camP = { 
					x: camera.position.x,
					y: camera.position.y,
					z: camera.position.z,
				};		
			
				var offset = 2.0;
				lookDir = normalize(vectSub(origin, camP));
				camRight = normalize(crossProd(lookDir, camUp));
				up = normalize(crossProd(camRight, lookDir));
				center = vectAdd(camP, vectMul(lookDir, offset));
				uR = vectAdd(vectAdd(center, up), vectMul(camRight, ratio));
				bR = vectAdd(vectSub(center, up), vectMul(camRight, ratio));
				uL = vectSub(vectAdd(center, up), vectMul(camRight, ratio));
				bL = vectSub(vectSub(center, up), vectMul(camRight, ratio));	
				
				uniforms.cameraPos.value = [camP.x, camP.y, camP.z];
				
				attributes.aPlotPosition.value[0] = uL;
				attributes.aPlotPosition.value[1] = uR;
				attributes.aPlotPosition.value[2] = bL;
				attributes.aPlotPosition.value[3] = bR;
				
				attributes.aPlotPosition.needsUpdate = true;

				renderer.clear();

				// Render first scene into texture
				//--renderer.render( sceneRTT, cameraRTT, rtTexture, true );
			
				// Render full screen quad with generated texture
				
				//render in center
				/*var left, bottom;
				left = wWidth/2.0;
				bottom = wHeight/2.0;
				renderer.setViewport( 100, 200, 640, 400 );
				//renderer.setScissor(left, bottom, 640, 400);
				//renderer.enableScissorTest ( true )*/

				//renderer.render( sceneRTT, cameraRTT );		
				//renderer.render( sampleTexScreen, cameraRTT );
				renderer.render(photonScene, perspCamera);
				
			}

			//-------------------------------------------------------------------------------------//
			//Vector Functions
			//-------------------------------------------------------------------------------------//
			function crossProd(v1, v2) {
    				return {x: v1.y*v2.z - v2.y*v1.z,
            			 y: v1.z*v2.x - v2.z*v1.x,
             			z: v1.x*v2.y - v2.x*v1.y };
  			}

  			//return rand dir (components from -1 to 1)
			function rand3()
			{
				var vX = Math.random()*2-1;
				var vY = Math.random()*2-1;
				var vZ = Math.random()*2-1;
				
				return {x: vX, y: vY, z: vZ};
			}

  			function normalize(v) {
				l = Math.sqrt(v.x*v.x + v.y*v.y + v.z*v.z);
				return { x: v.x/l, y: v.y/l, z: v.z/l };
			}

			function maxComp(v1, v2)
			{
				var r = {x:0, y:0, z:0};
				r.x = Math.max(v1.x, v2.x);
				r.y = Math.max(v1.y, v2.y);
				r.z = Math.max(v1.z, v2.z);

				return r;
			}

			function minComp(v1, v2)
			{
				var r = {x:0, y:0, z:0};
				r.x = Math.min(v1.x, v2.x);
				r.y = Math.min(v1.y, v2.y);
				r.z = Math.min(v1.z, v2.z);

				return r;
			}

			function dot(v1, v2)
			{
				return v1.x*v2.x+v1.y*v2.y+v1.z*v2.z;
			}

			function vMax(v)
			{
				return Math.max(v.x, v.y, v.z);
			}

			function vMin(v)
			{
				return Math.min(v.x, v.y, v.z);
			}
			
			function vCompDivide(v1, v2)
			{
				return {x: v1.x/v2.x, y: v1.y/v2.y, z: v1.z/v2.z};
			}

			function vDivide(v, d)
			{
				return {x: v.x/d, y: v.y/d, z: v.z/d};
			}
			function testVecFunctions()
			{
				var r;
				for(var i = 0; i < 10; i++)
				{
					//r = rand3();
					r = Math.random()-1;
				}
				
				/*var t1 = {x:2, y:4, z:6};
				var t2 = {x:2, y:2, z:2};
				
				var vNorm = normalize(t1);
				var vMaxComp = maxComp(t1, t2);
				var vMinComp = minComp(t1, t2);
				var vDot = dot(t1, t2);
				var max = vMax(t1);
				var min = vMin(t1);
				var compDivide = vCompDivide(t1, t2);
				var divide = vDivide(t1, 2);*/
			}
			
			function vCopy(v)
			{
				var r = {x: v.x, y: v.y, z: v.z};
				return r;
			}
			function vMultComponent(v1, v2)
			{
				return {x: v1.x*v2.x, y: v1.y*v2.y, z: v1.z*v2.z};
			}
			//---
			function vectAdd(v1, v2) {
				return { x: v1.x + v2.x, y: v1.y + v2.y, z: v1.z + v2.z };
			}
		      
			function vectSub(v1, v2) {
				return { x: v1.x - v2.x, y: v1.y - v2.y, z: v1.z - v2.z };
			}	
		      
			function vectMul(v, l) {
				return { x: v.x*l, y: v.y*l, z: v.z*l };
			}
			
			function distance(v1, v2) {
				return Math.sqrt((v1.x-v2.x)*(v1.x-v2.x) + (v1.y-v2.y)*(v1.y-v2.y) + (v1.z-v2.z)*(v1.z-v2.z));
			}		
			//-------------------------------------------------------------------------------------//
			//Start Program
			//-------------------------------------------------------------------------------------//
			//testVecFunctions();
			//testIntersections();
			//testPhoton();
			init();
			animate();

		</script>
	</body>
</html>
