
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - render-to-texture</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #111111;
				font-family:Monospace;
				font-size:13px;
				text-align:center;
				font-weight: bold;
				background-color: #111111;
				margin: 0px;
				overflow: hidden;
			}

			#info {
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
			}

			a {
				color: #ffffff;
			}

		</style>
	</head>
	<body>

		<div id="container"></div>
		<div id="info"><a href="http://threejs.org" target="_blank">three.js</a> render-to-texture webgl example</div>

		<script src="build/three.min.js"></script>
		<script src="js/Detector.js"></script>
		<script src="js/libs/stats.min.js"></script>
		<script src="js/controls/FirstPersonControls.js"></script>
		<script src="js/controls/TrackballControls.js"></script>
		<script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>

		<!--***FRAGMENT SHADER TEXTURE***-->				      
		<script id="fragment_shader_texture" type="x-shader/x-fragment">
			precision mediump float;
			
			bool intersectPlane(vec3 center, float size, vec3 lStart, vec3 lDir, vec3 n, out float dist);
			
  			const vec3 lightDir = vec3(0.577350269, 0.577350269, -0.577350269);
			const vec3 lightPos = vec3(-10.0, 0.0, 0.0);
			
			varying vec3 vPosition;
  			uniform vec3 cameraPos;
  			uniform vec3 sphere1Center;
  			uniform vec3 sphere2Center;
  			uniform vec3 sphere3Center;
			
			//colors for scene
			/*vec3 RED = vec3(0.63, 0.06, 0.04);
			vec3 BLUE = vec3(0.0, 0.0, 0.75);
			vec3 GREEN = vec3(0.15, 0.48, 0.09);
			vec3 WHITE = vec3(0.76, 0.75, 0.5);*/
			
			//int test[1];
			//test[0] = 2;
			
			//cube norms
			uniform vec3 norms[6];
			
			//cube colors
			uniform vec3 colors[6];	
			
			//refraction indices
			float nAir = 1.0;
			float nWater = 1.33;
			
			const int NUM_LIGHTS = 2, NUM_SHAPES = 2;
			
			struct PointLight
			{
				vec3 pos;
				vec3 col;
			};
			uniform PointLight lights[NUM_LIGHTS];
			
			const int SPHERE = 0, CUBE = 1;
			struct Shape
			{
				int type;
				float size;
				vec3 pos;
				vec3 diffuse;
				float reflectance;
				float transparency;
			};
			uniform Shape shapes[2];
			
			
			bool intersectCube(int s, vec3 lStart, vec3 lDir, out float dist, out int cubeSide)
			{
				//calc pos of all sides
				vec3 side[6];
				for(int i = 0; i < 6; i++){
					side[i] = shapes[s].pos;
				}
				
				float size = shapes[s].size;
				
				side[0].y += size;
				side[1].y -= size;
				side[2].x += size;
				side[3].x -= size;
				side[4].z += size;
				side[5].z -= size;
				
				//check intersection for each side
				float d = 10000.0, cD = 10000.0;
				
				for (int i = 0; i < 6; i++)
				{
					if (intersectPlane(side[i], size, lStart, lDir, norms[i], cD))
					{
						if (cD < d)
						{
							d = cD;
							cubeSide = i;
						}
					}
				}
				
				//return shortest distance
				dist = d;
				
				if (d < 10000.0) {
					return true;
				}
				
				return false;
			}
			

			bool intersectPlane(vec3 center, float size, vec3 lStart, vec3 lDir, vec3 n, out float dist)
			{
				//ray dir
				vec3 l = lDir;
				
				//ray origin
				vec3 l0 = lStart;
				
				//plane origin
				vec3 p0 = center;

				dist = 0.0;

				float denom = dot(l, n);
				if(denom == 0.0) return false;
				
				float num = dot((p0 - l0), n);
				dist = num/denom;
				if (dist < 0.0)
				{
					return false;
				}
				
				
				//float dP = distance(p0, p);
				vec3 p = (dist*l + l0);
				vec3 dP = p0-p;
				//float size = plane.size;
				if(abs(dP.x) > size || abs(dP.y) > size || abs(dP.z) > size)
				{
					return false;
				}
    				return true;
			}		

 			bool intersectSphere(int s, vec3 lStart, vec3 lDir, out float dist)
			{
    				//vec3 c = center - lStart;
				vec3 c = shapes[s].pos - lStart;
    				float b = dot(lDir, c);
    				float d = b*b - dot(c, c) + shapes[s].size;
    				if (d < 0.0) {
      					dist = 10000.0;
      					return false;
    				}

    				dist = b - sqrt(d);
    				if (dist < 0.0) {
      					dist = 10000.0;
      					return false;
    				}

					return true;
  			}		
			
			int intersectScene(vec3 rStart, vec3 rDir, out vec3 pos, out int cubeSide)
			{
				float d = 10000.0;
				float newD;
				int cSide;
				cubeSide = -1;
				int s = -1;
				
				//for (int i = 0; i < NUM_SHAPES; i++)
				for (int i = 0; i < 1/*NUM_SHAPES*/; i++)
				{
					if (shapes[i].type == SPHERE) {
						//bool intersectSphere(int s, vec3 lStart, vec3 lDir, out float dist)
						if (intersectSphere(i, rStart, rDir, newD))
						{
							if (newD < d) {
								d = newD;
								s = i;
							}
						}
					}
					if (shapes[i].type == CUBE) {
						//bool intersectCube(int s, vec3 lStart, vec3 lDir, out float dist, out int cubeSide)
						if (intersectCube(i, rStart, rDir, newD, cSide))
						{
							if (newD < d) {
								d = newD;
								s = i;
								cubeSide = cSide;
							}
						}
					}
				}
				pos = vec3(0.0, 0.0, 0.0);
				if (s > -1)
				{
					pos = rStart + d * rDir;
				}
				return s;
			}
			
			float intersectScene(vec3 rStart, vec3 rDir)
			{
				float d = 10000.0;
				float newD;
				int cubeSide = -1;
				//for (int i = 0; i < NUM_SHAPES; i++)
				for (int i = 0; i < 1/*NUM_SHAPES*/; i++)
				{
					if (shapes[i].type == SPHERE) {
						//bool intersectSphere(int s, vec3 lStart, vec3 lDir, out float dist)
						if (intersectSphere(i, rStart, rDir, newD))
						{
							if (newD < d) {
								d = newD;								
							}
						}
					}
					if (shapes[i].type == CUBE) {
						//bool intersectCube(int s, vec3 lStart, vec3 lDir, out float dist, out int cubeSide)
						if (intersectCube(i, rStart, rDir, newD, cubeSide))
						{
							if (newD < d) {
								d = newD;								
							}
						}
					}
				}
				return d;
			}
		
			vec3 colorAt(int s, vec3 pos, vec3 n, vec3 c)
			{
				vec3 color = vec3(0.0, 0.0, 0.0);
				//calc lighting
				for (int i = 0; i < 1; i++) /*********************only using one light for now***************/
				{
					
					vec3 lDir = (lights[i].pos - pos);
					float dist = length(lDir);					
					lDir = normalize(lDir);
					float lamb = dot(n, lDir);					
					//cull possible intersections if normals in diff dir's
					if ( lamb <= 0.0 )//return black
					{
						return vec3(1.0, 0.0, 1.0);
					}
					int cS;
					vec3 p;
					int tS;
					
					if((intersectScene((pos + 3.0*n), lDir)) < dist)
					{
						//vec3 rStart, vec3 rDir, out vec3 pos, out int cubeSide
						//tS = intersectScene(pos, lDir, p, cS);
						//return vec3(tS, 0.0, 0.0);
						return vec3(1.0, 1.0, 0.0);
					}
					
					//calc color					
					color += c * lights[i].col * lamb;
					float t = intersectScene((pos), lDir);
					//return vec3(dist/20.0, 0.0, 0.0);
					//color += lamb;
				}
				return color;
			}
			
  			void main(void)
  			{
				vec3 cameraDir = normalize(vPosition - cameraPos);
				vec3 pos, n, c;
				int s = -1, cSide = -1;
				s = intersectScene(cameraPos, cameraDir, pos, cSide);
				
				//if intersection do lighting calcs
				if (s > -1)
				{
					if (shapes[s].type == SPHERE) {
						n = normalize(pos - shapes[s].pos);
						c = shapes[s].diffuse;
					}
					if (shapes[s].type == CUBE) {
						n = norms[cSide];
						c = colors[cSide];
					}
					gl_FragColor = vec4(colorAt(s, pos, n, c), 1.0);
					//gl_FragColor = vec4(abs(n), 1.0);
				}
				else
				{
      					gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
    				}
				
				//bool intersectPlane(vec3 center, float size, vec3 lStart, vec3 lDir, vec3 n, out float dist)
				/*float d;
				vec3 center = vec3(0.0, 0.0, 0.0);
				vec3 norm = vec3(-1.0, 0.0, 0.0);*/
				
				/*if (intersectPlane(center, 2.0, cameraPos, cameraDir, norm, d))
				{
					gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
				}
				else
				{
					gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);	
				}*/
				
				//gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
				
				//gl_FragColor = vec4(lights[0].col, 1.0);
 			}
		</script>
		
		<!--***VERTEX SHADER TEXTURE***-->
		<script id="vertex_shader_texture" type="x-shader/x-vertex">

			attribute vec3 aPlotPosition;

			varying vec3 vPosition;

			void main() {
				vPosition =  aPlotPosition;
				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			}

		</script>

		<!--***FRAGMENT SHADER SCREEN***-->
		<script id="fragment_shader_screen" type="x-shader/x-fragment">

			varying vec2 vUv;

			uniform sampler2D tDiffuse;

			void main() {
				gl_FragColor = texture2D( tDiffuse, vUv );
			}

		</script>

		<!--***VERTEX SHADER SCREEN***-->
		<script id="vertex_shader_screen" type="x-shader/x-vertex">

			varying vec2 vUv;

			void main() {
				vUv = uv;
				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			}

		</script>

		<script>

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var container, stats;

			var cameraRTT, sceneRTT, sceneScreen, renderer, scene, camera;

			var uniforms, attributes, controls;

			var ratio = 1.6

			var w = 3.2;
			var h = 2;
			
			var camOffset = -5;
			
			var wWidth = window.innerWidth;
			var wHeight = window.innerHeight;			

			var rtTexture, material, quad;

			var delta = 0.01;

			var SPHERE = 0, CUBE = 1;

			var mesh1, mesh2;

			var lookDir; 
			
			var origin;
			var up;

			var t = 0;
			var center;			
			var plotPos;
			var attributes;

			init();
			animate();

			function init() {
				container = document.getElementById( 'container' );

				renderer = new THREE.WebGLRenderer();
				renderer.setSize( 640, 400 );
				renderer.autoClear = false;

				container.appendChild( renderer.domElement );

				lookDir = {x: 0, y: 0, z: 0};
				camUp = {x: 0, y: 1, z: 0};
				origin = {x: 0, y: 0, z: 0};			
				center = {x: 0, y: 0, z: 0};

				//mouse movement
				//camRotationMatrix = new THREE.Matrix4();
				cPos = new THREE.Vector3();
				startPos = new THREE.Vector3(0, 0, 20);
				cPos.copy(startPos);
				
				//camera
				cameraRTT = new THREE.OrthographicCamera( w / - 2, w / 2, h  / 2, h / - 2, -10000, 10000 );
				cameraRTT.position.z = 20;

				
				/*moving camera*/
				camera = new THREE.OrthographicCamera( w / - 2, w / 2, h  / 2, h / - 2, -10000, 10000 );
				camera.position.z = 20;
				
				//controls
				controls = new THREE.TrackballControls( camera, renderer.domElement );

				//scenes
				sceneRTT = new THREE.Scene();
				sceneScreen = new THREE.Scene();

				//txtre to render to
				rtTexture = new THREE.WebGLRenderTarget( 512, 512, { minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter, format: THREE.RGBFormat } );
				
				uniforms =
				{
					/**********************************************************/
					//--shapes
					//sphere
					"shapes[0].type": {
						type: 'i',
						value: CUBE						
					},
					"shapes[0].size": {
						type: 'f',
						value: 1.0
					},
					"shapes[0].pos": {
						type: 'fv',
						value: [0.0, 0.0, 0.0]
					},
					"shapes[0].diffuse": {
						type: 'fv',
						value: [0, 1, 0]
					},
					"shapes[0].reflectance": {
						type: 'f',
						value: 0.0
					},
					"shapes[0].transparency": {
						type: 'f',
						value: 1.0
					},
					//cube
					"shapes[1].type": {
						type: 'i',
						value: CUBE							
					},
					"shapes[1].size": {
						type: 'f',
						value: 3.0
					},
					"shapes[1].pos": {
						type: 'fv',
						value: [2, 0, 0]
					},
					"shapes[1].diffuse": {
						type: 'fv',
						value: [1, 0, 0]
					},
					"shapes[1].reflectance": {
						type: 'f',
						value: 0.0
					},
					"shapes[1].transparency": {
						type: 'f',
						value: 1.0
					},
					//--normals
					"norms[0]": {
						type: 'fv',
						value: [0, 1, 0]
					},
					"norms[1]": {
						type: 'fv',
						value: [0, -1, 0]
					},
					"norms[2]": {
						type: 'fv',
						value: [1, 0, 0]
					},
					"norms[3]": {
						type: 'fv',
						value: [-1, 0, 0]
					},
					"norms[4]": {
						type: 'fv',
						value: [0, 0, 1]
					},
					"norms[5]": {
						type: 'fv',
						value: [0, 0, -1]
					},
					//face colors
					"colors[0]": {
						type: 'fv',
						value: [0.76, 0.75, 0.5]
					},
					"colors[1]": {
						type: 'fv',
						value: [0.76, 0.75, 0.5]
					},
					"colors[2]": {
						type: 'fv',
						value: [0.63, 0.06, 0.04]
					},
					"colors[3]": {
						type: 'fv',
						value: [0.15, 0.48, 0.09]
					},
					"colors[4]": {
						type: 'fv',
						value: [0.76, 0.75, 0.5]
					},
					"colors[5]": {
						type: 'fv',
						value: [0.76, 0.75, 0.5]
					},
					//--lights
					"lights[0].pos": {
						type: 'fv',
						value: [-10, 0, 0]
					},
					"lights[0].col": {
						type: 'fv',
						value: [1.0, 1.0, 1.0]
					},
					"lights[1].pos": {
						type: 'fv',
						value: [10.0, 0.0, 0.0]
					},
					"lights[1].col": {
						type: 'fv',
						value: [1.0, 1.0, 1.0]
					},
					/**********************************************************/
					cameraPos: {
						type: 'fv', // vec3
						value: [0, 0, 0]
					},
					sphere1Center: {
						type: 'fv', // vec3
						value: [0, 0, 0]
					},
					sphere2Center: {
						type: 'fv', // vec3
						value: [0, 0, 0]
					},
					sphere3Center: {
						type: 'fv', // vec3
						value: [0, 0, 0]
					},
				};			

				attributes = {
					aPlotPosition: {
						type : 'v3',
						value : []
					},
				}
				
				plotPos = attributes.aPlotPosition.value;
				for (var i = 0; i < 4; i++) {
					plotPos[i] = 0;
				}

				material = new THREE.ShaderMaterial( {
					uniforms: uniforms,
					attributes: attributes,
					vertexShader: document.getElementById( 'vertex_shader_texture' ).textContent,
					fragmentShader: document.getElementById( 'fragment_shader_texture' ).textContent
				} );

				var materialScreen = new THREE.ShaderMaterial( {
					uniforms: { tDiffuse: { type: "t", value: rtTexture } },
					vertexShader: document.getElementById( 'vertex_shader_screen' ).textContent,
					fragmentShader: document.getElementById( 'fragment_shader_screen' ).textContent,
					depthWrite: false
				} );

				var plane = new THREE.PlaneGeometry( w, h);

				quad = new THREE.Mesh( plane, material );
				quad.position.z = 0;
				sceneRTT.add( quad );

				quad = new THREE.Mesh( plane, materialScreen );
				quad.position.z = 0;
				sceneScreen.add( quad );
				
				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				container.appendChild( stats.domElement );
			}

			function animate() {

				requestAnimationFrame( animate );
				stats.update();
				controls.update();
				render();				
			}						

			function render() {
				camera.updateMatrixWorld();
				camera.matrixWorldInverse.getInverse(camera.matrixWorld);			

				var time = Date.now() * 0.0015;
		
				/*update attributes*/
				//--update 4 corners
				
				cLeftT = viewDirection(camera.left, camera.top, camOffset);
    				cLeftB = viewDirection(camera.left, camera.bottom, camOffset);
    				cRightT= viewDirection(camera.right, camera.top, camOffset);
    				cRightB = viewDirection(camera.right, camera.bottom, camOffset);

				cLeftT.add(camera.position);
				cLeftB.add(camera.position);
				cRightT.add(camera.position);
				cRightB.add(camera.position);

				dUL = cLeftT.distanceTo(camera.position);
				dUR = cRightT.distanceTo(camera.position);
				dBL = cLeftB.distanceTo(camera.position);
				dBR = cRightB.distanceTo(camera.position);
				
   				camP = { 
					x: camera.position.x,
					y: camera.position.y,
					z: camera.position.z,
				};
		
			
				var offset = 6;
				lookDir = normalize(vectSub(origin, camP));
				camRight = normalize(crossProd(lookDir, camUp));
				up = normalize(crossProd(camRight, lookDir));
				center = vectAdd(camP, vectMul(lookDir, offset));
				uR = vectAdd(vectAdd(center, up), vectMul(camRight, ratio));
				bR = vectAdd(vectSub(center, up), vectMul(camRight, ratio));
				uL = vectSub(vectAdd(center, up), vectMul(camRight, ratio));
				bL = vectSub(vectSub(center, up), vectMul(camRight, ratio));
	
				
				uniforms.cameraPos.value = [camP.x, camP.y, camP.z];
				
				attributes.aPlotPosition.value[0] = uL;
				attributes.aPlotPosition.value[1] = uR;
				attributes.aPlotPosition.value[2] = bL;
				attributes.aPlotPosition.value[3] = bR;
				
				attributes.aPlotPosition.needsUpdate = true;

				renderer.clear();

				// Render first scene into texture

				// renderer.render( sceneRTT, cameraRTT, rtTexture, true );
			
				// Render full screen quad with generated texture
				
				//render in center
				/*var left, bottom;
				left = wWidth/2.0;
				bottom = wHeight/2.0;
				renderer.setViewport( 100, 200, 640, 400 );
				//renderer.setScissor(left, bottom, 640, 400);
				//renderer.enableScissorTest ( true )*/

				renderer.render( sceneRTT, cameraRTT );		
				//renderer.render(scene, camera);	   	

				t += 0.03;
    				if (t > Math.PI * 200) {
      					t -= Math.PI * 200;
   				}

			}

			function viewDirection(xLoc, yLoc, zLoc)
			{
				camera.updateMatrixWorld();
				var pLocal = new THREE.Vector3(xLoc, yLoc, zLoc);	
				var worldMat = camera.matrixWorld;
				var pWorld = pLocal.applyMatrix4(worldMat);
				var dir = pWorld.sub( camera.position );			

				return dir;
			}

			function crossProd(v1, v2) {
    				return {x: v1.y*v2.z - v2.y*v1.z,
            			 y: v1.z*v2.x - v2.z*v1.x,
             			z: v1.x*v2.y - v2.x*v1.y };
  			}

  			function normalize(v) {
				l = Math.sqrt(v.x*v.x + v.y*v.y + v.z*v.z);
				return { x: v.x/l, y: v.y/l, z: v.z/l };
			}

			function vectAdd(v1, v2) {
				return { x: v1.x + v2.x, y: v1.y + v2.y, z: v1.z + v2.z };
			}
		      
			function vectSub(v1, v2) {
				return { x: v1.x - v2.x, y: v1.y - v2.y, z: v1.z - v2.z };
			}	
		      
			function vectMul(v, l) {
				return { x: v.x*l, y: v.y*l, z: v.z*l };
			}
			
			function distance(v1, v2) {
				return Math.sqrt((v1.x-v2.x)*(v1.x-v2.x) + (v1.y-v2.y)*(v1.y-v2.y) + (v1.z-v2.z)*(v1.z-v2.z));
			}
		</script>
	</body>
</html>
