
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - render-to-texture</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #111111;
				font-family:Monospace;
				font-size:13px;
				text-align:center;
				font-weight: bold;
				background-color: #111111;
				margin: 0px;
				overflow: hidden;
			}

			#info {
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
			}

			a {
				color: #ffffff;
			}

		</style>
	</head>
	<body>

		<div id="container"></div>
		<div id="info"><a href="http://threejs.org" target="_blank">three.js</a> render-to-texture webgl example</div>

		<script src="build/three.min.js"></script>
		<script src="js/Detector.js"></script>
		<script src="js/libs/stats.min.js"></script>
		<script src="js/controls/FirstPersonControls.js"></script>
		<script src="js/controls/TrackballControls.js"></script>
		<script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>

		<!--***FRAGMENT SHADER TEXTURE***-->				      
		<script id="fragment_shader_texture" type="x-shader/x-fragment">
			precision mediump float;
			
			varying vec3 vPosition;
  			uniform vec3 cameraPos;
			
			bool intersectPlane(vec3 center, float size, vec3 n, vec3 lStart, vec3 lDir, out float dist);
			const vec3 ambientLight = vec3(1.0, 1.0, 1.0);		
			
			const int NUM_LIGHTS = 1;
			const int NUM_SHAPES = 8;
			
			struct PointLight
			{
				vec3 pos;
				vec3 col;
			};
			uniform PointLight lights[NUM_LIGHTS];
			
			const int SPHERE = 0;
			const int PLANE = 1;
			struct Shape
			{
				vec3 pos;
				vec3 norm;
				vec3 diffuse;				
				float reflectance;
				float transparency;
				float size;
				int  type;
			}currentShape;
			uniform Shape shapes[NUM_SHAPES];
			

			bool intersectPlane(vec3 center, float size, vec3 n, vec3 lStart, vec3 lDir, out float dist)
			{
				//ray dir
				vec3 l = lDir;
				
				//ray origin
				vec3 l0 = lStart;
				
				//plane origin
				vec3 p0 = center;

				dist = 0.0;
				
				//if not facing view dir not visible
				float lamb = dot(lDir, n);
				if (lamb > 0.0)
				{
					return false;
				}

				float denom = dot(l, n);
				if(denom == 0.0) return false;
				
				float num = dot((p0 - l0), n);
				dist = num/denom;
				if (dist < 0.0)
				{
					return false;
				}				
				
				//float dP = distance(p0, p);
				vec3 p = (dist*l + l0);
				vec3 dP = p0-p;
				//float size = plane.size;
				if(abs(dP.x) > size || abs(dP.y) > size || abs(dP.z) > size)
				{
					return false;
				}
    				return true;
			}		

			bool intersectSphere(float size, vec3 pos, vec3 rStart, vec3 rDir, out float dist)
			{
    				//vec3 c = center - lStart;
				vec3 c = pos - rStart;
    				float b = dot(rDir, c);
    				float d = b*b - dot(c, c) + size;
    				if (d < 0.0) {
      					dist = 10000.0;
      					return false;
    				}

    				float t1 = b - sqrt(d);
				float t2 = b + sqrt(d);
				
				if (t1 > 0.0 && t2 > 0.0) {
					if (t1 < t2)
					{
						dist = t1;
					}
					else
					{
						dist = t2;
					}
				}
				if ((t1 < 0.0 && t2 > 0.0) || (t1 > 0.0 && t2 < 0.0))
				{
					if (t1 > t2)
					{
						dist = t1;
					}
					else
					{
						dist = t2;
					}
				}
				if((t1 < 0.0) && (t2 < 0.0))
				{
					return false;
				}

				return true;
  			}		
			
			bool intersectScene(vec3 rStart, vec3 rDir, out vec3 pos)
			{
				float d = 10000.0;
				float newD;
				bool hit = false;				
				
				for (int i = 0; i < NUM_SHAPES; i++)
				//for (int i = 0; i < 1; i++)
				{
					if (shapes[i].type == SPHERE) {
						//bool intersectSphere(int s, vec3 lStart, vec3 lDir, out float dist)
						if (intersectSphere(shapes[i].size, shapes[i].pos, rStart, rDir, newD))
						{
							hit = true;
							if (newD < d) {
								d = newD;
								currentShape = shapes[i];
							}
						}
					}
					if (shapes[i].type == PLANE) {
						//bool intersectCube(int s, vec3 lStart, vec3 lDir, out float dist, out int cubeSide)
						//bool intersectPlane(vec3 center, float size, vec3 lStart, vec3 lDir, vec3 n, out float dist)
						if (intersectPlane(shapes[i].pos, shapes[i].size, shapes[i].norm, rStart, rDir, newD))
						{
							hit = true;
							if (newD < d) {
								d = newD;
								currentShape = shapes[i];
							}
							
						}
					}
				}
				//pos = vec3(0.0, 0.0, 0.0);
				if (hit)
				{
					pos = rStart + d * rDir;
				}
				
				return hit;
			}
			
			float intersectScene(vec3 rStart, vec3 rDir)
			{
				float d = 10000.0;
				float newD;
				for (int i = 0; i < NUM_SHAPES; i++)
				//for (int i = 0; i < 1; i++)
				{
					if (shapes[i].type == SPHERE) {
						//bool intersectSphere(int s, vec3 lStart, vec3 lDir, out float dist)
						if (intersectSphere(shapes[i].size, shapes[i].pos, rStart, rDir, newD))
						{
							if (newD < d) {
								d = newD;								
							}
						}
					}
					if (shapes[i].type == PLANE) {
						//bool intersectCube(int s, vec3 lStart, vec3 lDir, out float dist, out int cubeSide)
						//bool intersectPlane(vec3 center, float size, vec3 lStart, vec3 lDir, vec3 n, out float dist)
						if (intersectPlane(shapes[i].pos, shapes[i].size, shapes[i].norm, rStart, rDir, newD))
						{
							if (newD < d) {
								d = newD;								
							}
						}
					}
				}
				return d;
			}
		
			vec3 colorAt(vec3 c, vec3 pos, vec3 n)
			{
				vec3 color = vec3(0.0, 0.0, 0.0);
				//calc lighting
				for (int i = 0; i < 1; i++) 
				{
					
					vec3 lDir = (lights[i].pos - pos);
					float dist = length(lDir);					
					lDir = normalize(lDir);
					float lamb = dot(n, lDir);					
					//cull possible intersections if normals in diff dir's
					if ( lamb <= 0.0 )//return black
					{
						//return vec3(0.0, 0.0, 0.0);
						continue;
					}
					//color black if position obstructed from light
					if((intersectScene((pos + 0.01*n), lDir)) < dist)//add 0.01 for if ray orgin in plane
					{
						//return vec3(0.0, 0.0, 0.0);
						continue;
					}			
					
					//calc color					
					color += c * lights[i].col * lamb;
				}
				//add ambient light			
				color += ambientLight * c;
				return color;
			}
			
			vec3 refrDir(float n1, float n2, vec3 norm, vec3 i)
			{
				float n = n1/n2;
				float cosI = dot(-i, norm);
				float sin2T = n * n * ( 1.0 - cosI * cosI);
				if (sin2T > 1.0)//total internal reflection - *****what ot do in this case?
				{
					return vec3(0.0, 0.0, 0.0);
				}
				float cosT = sqrt(1.0 - sin2T);
				return n * i + (n * cosI - cosT) * norm;
			}
			
			float fresnel(float n1, float n2, vec3 norm, vec3 i)//schlick's approx
			{
				float ref = (n1-n2)/(n1+n2);
				ref *= ref;
				float cosX = dot(-i, norm);
				if (n1 > n2)
				{
					float n = n1/n2;
					float sin2T = n * n * (1.0-cosX * cosX);
					if (sin2T > 1.0)
					{
						return 1.0;
					}
					cosX = sqrt(1.0-sin2T);
				}
				float x = 1.0-cosX;
				return ref + (1.0-ref) * x * x * x * x * x;
			}
			
			/*float reflectance(float n1, float n2, vec3 norm, vec3 i)
			{
				float n = n1/n2;
				float cosI = -dot(norm, i);
				float sinT2 = n*n*(1.0-cosI*cosI);
				if (sinT2 >1.0)
				{
					return 1.0;
				}
				float cosT = sqrt(1.0-sinT2);
				float rOrth = (n1*cosI-n2*cosT)/(n1*cosI+n2*cosT);
				float rPar = (n2*cosI-n1*cosT)/(n2*cosI+n1*cosT);
				return (rOrth*rOrth + rPar*rPar)/2.0;
				return 1.0;
			}*/
			
  			void main(void)
  			{
				vec3 cameraDir = normalize(vPosition - cameraPos);
				vec3 sPos, sN, sC, n, nO, c, cO, surfC, reflD, reflC = vec3(0.0, 0.0, 0.0), reflP, refrD, refrC, refrP;
				bool hit = false;
				Shape surfShape, reflShape, refrShape;
				
				hit = intersectScene(cameraPos, cameraDir, sPos);
				
				//if intersection do lighting calcs
				if (hit)
				{
					surfShape = currentShape;
					
					//surface color
					if (surfShape.type == SPHERE)
					{
						sN = normalize(sPos - currentShape.pos);
					}
					if (surfShape.type == PLANE)
					{
						sN = currentShape.norm;
					}
					sC = currentShape.diffuse;

					surfC = colorAt(sC, sPos, sN);
					
					vec3 rN, rC;
					//reflection color
					if (surfShape.reflectance > 0.0)
					{
						//reflect about normal
						reflD = reflect(cameraDir, sN);
						if (intersectScene(sPos + 0.01*sN, reflD, reflP))
						{
							reflShape = currentShape;
							if (reflShape.type == SPHERE)
							{
								rN = normalize(reflP - reflShape.pos);
							}
							if (reflShape.type == PLANE)
							{
								rN = reflShape.norm;		
							}
							rC = reflShape.diffuse;
							reflC = colorAt(rC, reflP, rN);
						}
					}
					
					vec3 tN, tC;
					vec3 refrD2, refrP2;
					//refraction color
					if (surfShape.transparency > 0.0)
					{
						//1st intersection
						refrD = refrDir(1.0, 1.33, sN, cameraDir);						
						if(intersectScene(sPos - 0.01*sN, refrD, refrP))
						{
							refrShape = currentShape;
							if(refrShape.type == SPHERE)
							{
								tN = -1.0*normalize(refrP - refrShape.pos);
							}
							if(refrShape.type == PLANE)
							{
								tN = -1.0*refrShape.norm;
							}
							
							//2nd intersection
							//--reset tC
							tC = vec3(0.0, 0.0, 0.0);
							refrD2 = refrDir(1.33, 1.0, tN, refrD);
							if(intersectScene(refrP - 0.01*tN, refrD2, refrP2))
							{
								refrShape = currentShape;
								if(refrShape.type == SPHERE)
								{
									tN = normalize(refrP2 - refrShape.pos);
								}
								if(refrShape.type == PLANE)
								{
									tN = refrShape.norm;
								}
								tC = refrShape.diffuse;
								refrC = colorAt(tC, refrP2, tN);
							}
						}
					}
					
					//float fresnel(float n1, float n2, vec3 norm, vec3 i)//schlick's approx
					//float f = fresnel(1.0, 1.33, sN, cameraDir);
					//vec3 finalC = (f*reflC*surfShape.reflectance + (1.0-f)*refrC*surfShape.transparency) + surfC;
					//gl_FragColor = vec4(f, 0.0, 0.0 1.0);
					gl_FragColor = vec4(surfC, 1.0);
					//gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
					
				}
				else
				{
      					gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
    				}
				//gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
 			}
		</script>
		
		<!--***VERTEX SHADER TEXTURE***-->
		<script id="vertex_shader_texture" type="x-shader/x-vertex">

			attribute vec3 aPlotPosition;

			varying vec3 vPosition;

			void main() {
				vPosition =  aPlotPosition;
				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			}

		</script>

		<!--***FRAGMENT SHADER SCREEN***-->
		<script id="fragment_shader_screen" type="x-shader/x-fragment">

			varying vec2 vUv;

			uniform sampler2D tDiffuse;

			void main() {
				gl_FragColor = texture2D( tDiffuse, vUv );
			}

		</script>

		<!--***VERTEX SHADER SCREEN***-->
		<script id="vertex_shader_screen" type="x-shader/x-vertex">

			varying vec2 vUv;

			void main() {
				vUv = uv;
				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			}

		</script>

		<script>

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var container, stats;

			var cameraRTT, sceneRTT, sceneScreen, renderer, scene, camera;

			var uniforms, attributes, controls;

			var ratio = 1.6

			var w = 3.2;
			var h = 2;
			
			var camOffset = -.5;
			
			//var wWidth = window.innerWidth;
			//var wHeight = window.innerHeight;			

			var rtTexture, material, quad;

			var delta = 0.01;

			var SPHERE = 0, PLANE = 1;

			var mesh1, mesh2;

			var lookDir; 
			
			var origin;
			var up;

			var t = 0;
			var center;			
			var plotPos;
			var attributes;

			init();
			animate();
			
			function cubePos(pos, size) {
				var posArray = [];
				var offsetX = {x: size, y: 0.0, z: 0.0};
				var offsetY = {x: 0.0, y: size, z: 0.0};
				var offsetZ = {x: 0.0, y: 0.0, z: size};				
				
				posArray[0] = vectAdd(pos, offsetX);
				posArray[1] = vectSub(pos, offsetX);
				posArray[2] = vectAdd(pos, offsetY);
				posArray[3] = vectSub(pos, offsetY);
				posArray[4] = vectAdd(pos, offsetZ);
				posArray[5] = vectSub(pos, offsetZ);
				
				var positions = new Array();
				
				for (var i = 0; i < 6; i++) {
					positions[i] = [];					
					positions[i][0] = posArray[i].x;
					positions[i][1] = posArray[i].y;
					positions[i][2] = posArray[i].z;
				}				
				return positions;
			}

			function init() {
				container = document.getElementById( 'container' );

				renderer = new THREE.WebGLRenderer();
				renderer.setSize( 640, 400 );
				renderer.autoClear = false;

				container.appendChild( renderer.domElement );

				lookDir = {x: 0, y: 0, z: 0};
				camUp = {x: 0, y: 1, z: 0};
				origin = {x: 0, y: 0, z: 0};			
				center = {x: 0, y: 0, z: 0};

				
				
				//camera
				cameraRTT = new THREE.OrthographicCamera( w / - 2, w / 2, h  / 2, h / - 2, -10000, 10000 );
				cameraRTT.position.z = 20;

				
				/*moving camera*/
				camera = new THREE.OrthographicCamera( w / - 2, w / 2, h  / 2, h / - 2, -10000, 10000 );
				camera.position.z = 15;
				
				//controls
				controls = new THREE.TrackballControls( camera, renderer.domElement );

				//scenes
				sceneRTT = new THREE.Scene();
				sceneScreen = new THREE.Scene();

				//txtre to render to
				rtTexture = new THREE.WebGLRenderTarget( 512, 512, { minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter, format: THREE.RGBFormat } );
				
				//cube stuff
				var SIZE = 3.0;
				
				var cPos = {x:0, y:0, z:0};
				var positionsArray = cubePos(cPos, SIZE);
				
				var normalsArray = new Array();
				normalsArray[0] = [-1, 0, 0];
				normalsArray[1] = [1, 0, 0];
				normalsArray[2] = [0, -1, 0];
				normalsArray[3] = [0, 1, 0];
				normalsArray[4] = [0, 0, -1];
				normalsArray[5] = [0, 0, 1];
				
				var GREEN = [0, 1, 0];//[0.15, 0.48, 0.09];
				var RED = [1, 0, 0];//[0.63, 0.06, 0.04];
				var WHITE = [1, 1, 1];//[0.76, 0.75, 0.5];
				
				
				
				/*struct Shape
				{
					vec3 pos;
					vec3 norm;
					vec3 diffuse;				
					float reflectance;
					float transparency;
					float size;
					int  type;
				}currentShape;*/
				
				
				
				
				
				uniforms =
				{
					/**********************************************************/
					//--shapes
					/*"shapes[0].pos": {
						type: 'fv',
						value: [1,-1,0]//[0.5, 0.5, 0.5]//[0, 0, 0]////
					},
					"shapes[0].norm": {
						type: 'fv',
						value: [0, 0, 0]//[0.5, 0.5, 0.5]//[0, 0, 0]////
					},
					"shapes[0].diffuse": {
						type: 'fv',
						value: [.3, 0, 0]
					},
					"shapes[0].reflectance": {
						type: 'f',
						value: 0.0
					},					
					"shapes[0].transparency": {
						type: 'f',
						value: 0.0
					},
					"shapes[0].size": {
						type: 'f',
						value: 2.0//6.0
					},
					"shapes[0].type": {
						type: 'i',
						value: SPHERE						
					},*/
					//plane1
					"shapes[0].pos": {
						type: 'fv',
						value: positionsArray[0]//[0.5, 0.5, 0.5]//[0, 0, 0]////
					},
					"shapes[0].norm": {
						type: 'fv',
						value: normalsArray[0]//[0.5, 0.5, 0.5]//[0, 0, 0]////
					},
					"shapes[0].diffuse": {
						type: 'fv',
						value: [0.15, 0.48, 0.09]//[.3, 0, 0]////GREEN
					},
					"shapes[0].reflectance": {
						type: 'f',
						value: 0.0
					},					
					"shapes[0].transparency": {
						type: 'f',
						value: 0.0
					},
					"shapes[0].size": {
						type: 'f',
						value: SIZE//6.0
					},
					"shapes[0].type": {
						type: 'i',
						value: PLANE						
					},
					//plane2
					"shapes[1].pos": {
						type: 'fv',
						value: positionsArray[1]//[0.5, 0.5, 0.5]//[0, 0, 0]////
					},
					"shapes[1].norm": {
						type: 'fv',
						value: normalsArray[1]//[0.5, 0.5, 0.5]//[0, 0, 0]////
					},
					"shapes[1].diffuse": {
						type: 'fv',
						value: [0.63, 0.06, 0.04]//[.3, 0, 0]////RED
					},
					"shapes[1].reflectance": {
						type: 'f',
						value: 0.0
					},					
					"shapes[1].transparency": {
						type: 'f',
						value: 0.0
					},
					"shapes[1].size": {
						type: 'f',
						value: SIZE//6.0
					},
					"shapes[1].type": {
						type: 'i',
						value: PLANE						
					},
					//plane 3
					"shapes[2].pos": {
						type: 'fv',
						value: positionsArray[2]//[0.5, 0.5, 0.5]//[0, 0, 0]////
					},
					"shapes[2].norm": {
						type: 'fv',
						value: normalsArray[2]//[0.5, 0.5, 0.5]//[0, 0, 0]////
					},
					"shapes[2].diffuse": {
						type: 'fv',
						value: [0.76, 0.75, 0.5]//[.3, 0, 0]////WHITE
					},
					"shapes[2].reflectance": {
						type: 'f',
						value: 0.0
					},					
					"shapes[2].transparency": {
						type: 'f',
						value: 0.0
					},
					"shapes[2].size": {
						type: 'f',
						value: SIZE//6.0
					},
					"shapes[2].type": {
						type: 'i',
						value: PLANE						
					},
					//plane4
					"shapes[3].pos": {
						type: 'fv',
						value: positionsArray[3]//[0.5, 0.5, 0.5]//[0, 0, 0]////
					},
					"shapes[3].norm": {
						type: 'fv',
						value: normalsArray[3]//[0.5, 0.5, 0.5]//[0, 0, 0]////
					},
					"shapes[3].diffuse": {
						type: 'fv',
						value: [0.76, 0.75, 0.5]//[.3, 0, 0]//[0.76, 0.75, 0.5]//WHITE
					},
					"shapes[3].reflectance": {
						type: 'f',
						value: 0.0
					},					
					"shapes[3].transparency": {
						type: 'f',
						value: 0.0
					},
					"shapes[3].size": {
						type: 'f',
						value: SIZE//6.0
					},
					"shapes[3].type": {
						type: 'i',
						value: PLANE						
					},
					//plane5
					"shapes[4].pos": {
						type: 'fv',
						value: positionsArray[4]//[0.5, 0.5, 0.5]//[0, 0, 0]////
					},
					"shapes[4].norm": {
						type: 'fv',
						value: normalsArray[4]//[0.5, 0.5, 0.5]//[0, 0, 0]////
					},
					"shapes[4].diffuse": {
						type: 'fv',
						value: [0.76, 0.75, 0.5]//[.3, 0, 0]//[0.76, 0.75, 0.5]//WHITE
					},
					"shapes[4].reflectance": {
						type: 'f',
						value: 0.0
					},					
					"shapes[4].transparency": {
						type: 'f',
						value: 0.0
					},
					"shapes[4].size": {
						type: 'f',
						value: SIZE//6.0
					},
					"shapes[4].type": {
						type: 'i',
						value: PLANE						
					},
					//plane6
					"shapes[5].pos": {
						type: 'fv',
						value: positionsArray[5]//[0.5, 0.5, 0.5]//[0, 0, 0]////
					},
					"shapes[5].norm": {
						type: 'fv',
						value: normalsArray[5]//[0.5, 0.5, 0.5]//[0, 0, 0]////
					},
					"shapes[5].diffuse": {
						type: 'fv',
						value: [0.76, 0.75, 0.5]//[.3, 0, 0]//[0.76, 0.75, 0.5]//WHITE
					},
					"shapes[5].reflectance": {
						type: 'f',
						value: 0.0
					},					
					"shapes[5].transparency": {
						type: 'f',
						value: 0.0
					},
					"shapes[5].size": {
						type: 'f',
						value: SIZE//6.0
					},
					"shapes[5].type": {
						type: 'i',
						value: PLANE						
					},
					//sphere1
					"shapes[6].pos": {
						type: 'fv',
						value: [-1, 1, -1]//[0.5, 0.5, 0.5]//[0, 0, 0]////
					},
					"shapes[6].norm": {
						type: 'fv',
						value: [0, 0, 0]//[0.5, 0.5, 0.5]//[0, 0, 0]////
					},
					"shapes[6].diffuse": {
						type: 'fv',
						value: [.3, 0, 0]
					},
					"shapes[6].reflectance": {
						type: 'f',
						value: 0.0
					},					
					"shapes[6].transparency": {
						type: 'f',
						value: 0.0
					},
					"shapes[6].size": {
						type: 'f',
						value: 1.0//6.0
					},
					"shapes[6].type": {
						type: 'i',
						value: SPHERE						
					},
					//sphere2
					"shapes[7].pos": {
						type: 'fv',
						value: [1, -1, 1]//[0.5, 0.5, 0.5]//[0, 0, 0]////
					},
					"shapes[7].norm": {
						type: 'fv',
						value: [0, 0, 0]//[0.5, 0.5, 0.5]//[0, 0, 0]////
					},
					"shapes[7].diffuse": {
						type: 'fv',
						value: [.3, 0, 0]
					},
					"shapes[7].reflectance": {
						type: 'f',
						value: 0.0
					},					
					"shapes[7].transparency": {
						type: 'f',
						value: 0.0
					},
					"shapes[7].size": {
						type: 'f',
						value: 1.0//6.0
					},
					"shapes[7].type": {
						type: 'i',
						value: SPHERE						
					},		
					//--lights
					"lights[0].pos": {
						type: 'fv',
						value: [-10, 0, 0]
					},
					"lights[0].col": {
						type: 'fv',
						value: [1.0, 1.0, 1.0]
					},
					"lights[1].pos": {
						type: 'fv',
						value: [-10.0, 0.0, 0.0]
					},
					"lights[1].col": {
						type: 'fv',
						value: [1.0, 1.0, 1.0]
					},
					/**********************************************************/
					cameraPos: {
						type: 'fv', // vec3
						value: [0, 0, 0]
					},
					sphere1Center: {
						type: 'fv', // vec3
						value: [0, 0, 0]
					},
					sphere2Center: {
						type: 'fv', // vec3
						value: [0, 0, 0]
					},
					sphere3Center: {
						type: 'fv', // vec3
						value: [0, 0, 0]
					},
				};			

				attributes = {
					aPlotPosition: {
						type : 'v3',
						value : []
					},
				}
				
				plotPos = attributes.aPlotPosition.value;
				for (var i = 0; i < 4; i++) {
					plotPos[i] = 0;
				}

				material = new THREE.ShaderMaterial( {
					uniforms: uniforms,
					attributes: attributes,
					vertexShader: document.getElementById( 'vertex_shader_texture' ).textContent,
					fragmentShader: document.getElementById( 'fragment_shader_texture' ).textContent
				} );

				var materialScreen = new THREE.ShaderMaterial( {
					uniforms: { tDiffuse: { type: "t", value: rtTexture } },
					vertexShader: document.getElementById( 'vertex_shader_screen' ).textContent,
					fragmentShader: document.getElementById( 'fragment_shader_screen' ).textContent,
					depthWrite: false
				} );

				var plane = new THREE.PlaneGeometry( w, h);

				quad = new THREE.Mesh( plane, material );
				quad.position.z = 0;
				sceneRTT.add( quad );

				quad = new THREE.Mesh( plane, materialScreen );
				quad.position.z = 0;
				sceneScreen.add( quad );
				
				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				container.appendChild( stats.domElement );
			}

			function animate() {

				requestAnimationFrame( animate );
				stats.update();
				controls.update();
				render();				
			}						

			function render() {
				camera.updateMatrixWorld();
				camera.matrixWorldInverse.getInverse(camera.matrixWorld);			

				var time = Date.now() * 0.0015;
		
				/*update attributes*/
				//--update 4 corners				
   				camP = { 
					x: camera.position.x,
					y: camera.position.y,
					z: camera.position.z,
				};		
			
				var offset = 2.0;
				lookDir = normalize(vectSub(origin, camP));
				camRight = normalize(crossProd(lookDir, camUp));
				up = normalize(crossProd(camRight, lookDir));
				center = vectAdd(camP, vectMul(lookDir, offset));
				uR = vectAdd(vectAdd(center, up), vectMul(camRight, ratio));
				bR = vectAdd(vectSub(center, up), vectMul(camRight, ratio));
				uL = vectSub(vectAdd(center, up), vectMul(camRight, ratio));
				bL = vectSub(vectSub(center, up), vectMul(camRight, ratio));	
				
				uniforms.cameraPos.value = [camP.x, camP.y, camP.z];
				
				attributes.aPlotPosition.value[0] = uL;
				attributes.aPlotPosition.value[1] = uR;
				attributes.aPlotPosition.value[2] = bL;
				attributes.aPlotPosition.value[3] = bR;
				
				attributes.aPlotPosition.needsUpdate = true;

				renderer.clear();

				// Render first scene into texture

				// renderer.render( sceneRTT, cameraRTT, rtTexture, true );
			
				// Render full screen quad with generated texture
				
				//render in center
				/*var left, bottom;
				left = wWidth/2.0;
				bottom = wHeight/2.0;
				renderer.setViewport( 100, 200, 640, 400 );
				//renderer.setScissor(left, bottom, 640, 400);
				//renderer.enableScissorTest ( true )*/

				renderer.render( sceneRTT, cameraRTT );		
				//renderer.render(scene, camera);	  
			}

			function viewDirection(xLoc, yLoc, zLoc)
			{
				camera.updateMatrixWorld();
				var pLocal = new THREE.Vector3(xLoc, yLoc, zLoc);	
				var worldMat = camera.matrixWorld;
				var pWorld = pLocal.applyMatrix4(worldMat);
				var dir = pWorld.sub( camera.position );			

				return dir;
			}

			function crossProd(v1, v2) {
    				return {x: v1.y*v2.z - v2.y*v1.z,
            			 y: v1.z*v2.x - v2.z*v1.x,
             			z: v1.x*v2.y - v2.x*v1.y };
  			}

  			function normalize(v) {
				l = Math.sqrt(v.x*v.x + v.y*v.y + v.z*v.z);
				return { x: v.x/l, y: v.y/l, z: v.z/l };
			}

			function vectAdd(v1, v2) {
				return { x: v1.x + v2.x, y: v1.y + v2.y, z: v1.z + v2.z };
			}
		      
			function vectSub(v1, v2) {
				return { x: v1.x - v2.x, y: v1.y - v2.y, z: v1.z - v2.z };
			}	
		      
			function vectMul(v, l) {
				return { x: v.x*l, y: v.y*l, z: v.z*l };
			}
			
			function distance(v1, v2) {
				return Math.sqrt((v1.x-v2.x)*(v1.x-v2.x) + (v1.y-v2.y)*(v1.y-v2.y) + (v1.z-v2.z)*(v1.z-v2.z));
			}
		</script>
	</body>
</html>
