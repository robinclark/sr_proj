
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - render-to-texture</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #101011;
				font-family:Monospace;
				font-size:13px;
				text-align:center;
				font-weight: bold;
				background-color: #101011;
				margin: 0px;
				overflow: hidden;
			}

			#info {
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
			}

			a {
				color: #ffffff;
			}

		</style>
	</head>
	<body>

		<div id="container"></div>
		<div id="info"><a href="http://threejs.org" target="_blank">three.js</a> render-to-texture webgl example</div>

		<script src="build/three.min.js"></script>
		<script src="js/Detector.js"></script>
		<script src="js/libs/stats.min.js"></script>
		<script src="js/controls/FirstPersonControls.js"></script>
		<script src="js/controls/TrackballControls.js"></script>

		<!--***FRAGMENT SHADER TEXTURE***-->				      
		<script id="fragment_shader_texture" type="x-shader/x-fragment">
			precision mediump float;

  			const vec3 lightDir = vec3(0.577350269, 0.577350269, -0.577350269);

			varying vec3 vPosition;

  			uniform vec3 cameraPos;
  			uniform vec3 sphere1Center;
  			uniform vec3 sphere2Center;
  			uniform vec3 sphere3Center;

 			bool intersectSphere(vec3 center, vec3 lStart, vec3 lDir, out float dist)
			{
    				vec3 c = center - lStart;
    				float b = dot(lDir, c);
    				float d = b*b - dot(c, c) + 1.0;
    				if (d < 0.0) {
      					dist = 10000.0;
      					return false;
    				}

    				dist = b - sqrt(d);
    				if (dist < 0.0) {
      					dist = 10000.0;
      					return false;
    				}

    				return true;
  			}

  			vec3 lightAt(vec3 N, vec3 V, vec3 color)
			{
    				vec3 L = lightDir;
    				vec3 R = reflect(-L, N);

    				float c = 0.3 + 0.4 * pow(max(dot(R, V), 0.0), 30.0) + 0.7 * dot(L, N);

    				if (c > 1.0) {
      					return mix(color, vec3(1.6, 1.6, 1.6), c - 1.0);
    				}

    				return c * color;
  			}

  			bool intersectWorld(vec3 lStart, vec3 lDir, out vec3 pos, out vec3 normal, out vec3 color)
			{
    				float d1, d2, d3;
    				bool h1, h2, h3;

    				h1 = intersectSphere(sphere1Center, lStart, lDir, d1);
    				h2 = intersectSphere(sphere2Center, lStart, lDir, d2);
    				h3 = intersectSphere(sphere3Center, lStart, lDir, d3);

    				if (h1 && d1 < d2 && d1 < d3)
				{
      					pos = lStart + d1 * lDir;
      					normal = pos - sphere1Center;
      					color = vec3(0.0, 0.0, 0.9);
    				}
    				else if (h2 && d2 < d3)
				{
      					pos = lStart + d2 * lDir;
      					normal = pos - sphere2Center;
      					color = vec3(0.9, 0.0, 0.0);
    				}
    				else if (h3) {
      					pos = lStart + d3 * lDir;
      					normal = pos - sphere3Center;
      					color = vec3(0.0, 0.9, 0.0);
    				}
    				else if (lDir.y < -0.01)
				{
     					pos = lStart + ((lStart.y + 2.7) / -lDir.y) * lDir;
      					if (pos.x*pos.x + pos.z*pos.z > 30.0)
					{
        					return false;
      					}

      					normal = vec3(0.0, 1.0, 0.0);

      					if (fract(pos.x / 5.0) > 0.5 == fract(pos.z / 5.0) > 0.5)
					{
        					color = vec3(1.0);
      					}
      					else
					{
        					color = vec3(0.0);
      					}
    				}
    				else
				{
     					return false;
    				}

    				return true;
  			}

  			void main(void)
  			{
    				vec3 cameraDir = normalize(vPosition - cameraPos);

    				vec3 p1, norm, p2;
    				vec3 col, colT, colM, col3;
   				if (intersectWorld(cameraPos, cameraDir, p1, norm, colT))
				{
      					col = lightAt(norm, -cameraDir, colT);
      					colM = (colT + vec3(0.7)) / 1.7;
      					cameraDir = reflect(cameraDir, norm);
      					if (intersectWorld(p1, cameraDir, p2, norm, colT))
					{
        					col += lightAt(norm, -cameraDir, colT) * colM;
        					colM *= (colT + vec3(0.7)) / 1.7;
        					cameraDir = reflect(cameraDir, norm);
        					if (intersectWorld(p2, cameraDir, p1, norm, colT))
						{
          						col += lightAt(norm, -cameraDir, colT) * colM;
        					}
      					}

      					gl_FragColor = vec4(col, 1.0);
					//gl_FragColor = vec4(0.0, 1.0, gl_FragCoord.z, 1.0);
    				}
    				else
				{
      					gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
					//gl_FragColor = vec4(0.0, 1.0, gl_FragCoord.z, 1.0);
    				}
 			}

		</script>

		<!--***VERTEX SHADER TEXTURE***-->
		<script id="vertex_shader_texture" type="x-shader/x-vertex">

			attribute vec3 aPlotPosition;

			varying vec3 vPosition;

			void main() {
				vPosition =  aPlotPosition;
				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				//gl_Position = vec4(aPlotPosition,1);
			}

		</script>

		<!--***FRAGMENT SHADER SCREEN***-->
		<script id="fragment_shader_screen" type="x-shader/x-fragment">

			varying vec2 vUv;

			uniform sampler2D tDiffuse;

			void main() {
				gl_FragColor = texture2D( tDiffuse, vUv );
			}

		</script>

		<!--***VERTEX SHADER SCREEN***-->
		<script id="vertex_shader_screen" type="x-shader/x-vertex">

			varying vec2 vUv;

			void main() {
				vUv = uv;
				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			}

		</script>

		<script>

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var container, stats;

			var cameraRTT, sceneRTT, sceneScreen, renderer;

			var uniforms, attributes, controls;
			var plotPos;

			var ratio = 1.6

			var w = 3.2;
			var h = 2;
			var camOffset = 20;
			
			var wWidth = window.innerWidth;
			var wHeight = window.innerHeight;			

			var rtTexture, material, quad;

			var delta = 0.01;

			init();
			animate();

			function init() {

				//alert(wWidth + ", " + wHeight);

				container = document.getElementById( 'container' );
				
				//camera
				cameraRTT = new THREE.OrthographicCamera( w / - 2, w / 2, h  / 2, h / - 2, -10000, 10000 );
				//cameraRTT = new THREE.OrthographicCamera( -1.6, 1.6, 1, -1, -10000, 10000 );
				cameraRTT.position.z = 20;

				
				/*moving camera*/
				camera = new THREE.OrthographicCamera( w / - 2, w / 2, h  / 2, h / - 2, -10000, 10000 );
				//camera.position.z = 20;
				//camera = new THREE.OrthographicCamera( -1.6, 1.6, 1, -1, -10000, 10000 );
				//camera.position.x = 0;
				camera.position.y = 5;
				camera.position.z = 20;
				
				//controls
				controls = new THREE.TrackballControls( camera );	

				//scenes
				sceneRTT = new THREE.Scene();
				sceneScreen = new THREE.Scene();

				//txtre to render to
				rtTexture = new THREE.WebGLRenderTarget( 512, 512, { minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter, format: THREE.RGBFormat } );
				
				uniforms = {
					cameraPos: {
						type: 'fv', // vec3
						value: [0, 0, 0]
					},
					sphere1Center: {
						type: 'fv', // vec3
						value: [0, 0, 0]
					},
					sphere2Center: {
						type: 'fv', // vec3
						value: [0, 0, 0]
					},
					sphere3Center: {
						type: 'fv', // vec3
						value: [0, 0, 0]
					},
				};			

				attributes = {
					aPlotPosition: {
						type : 'v3',
						value : []
					},
				}	

				material = new THREE.ShaderMaterial( {
					uniforms: uniforms,
					attributes: attributes,
					vertexShader: document.getElementById( 'vertex_shader_texture' ).textContent,
					fragmentShader: document.getElementById( 'fragment_shader_texture' ).textContent
				} );

				var materialScreen = new THREE.ShaderMaterial( {
					uniforms: { tDiffuse: { type: "t", value: rtTexture } },
					vertexShader: document.getElementById( 'vertex_shader_screen' ).textContent,
					fragmentShader: document.getElementById( 'fragment_shader_screen' ).textContent,
					depthWrite: false
				} );

				var plane = new THREE.PlaneGeometry( w, h);

				quad = new THREE.Mesh( plane, material );
				quad.position.z = 0;
				sceneRTT.add( quad );

				quad = new THREE.Mesh( plane, materialScreen );
				quad.position.z = 0;
				sceneScreen.add( quad );

				renderer = new THREE.WebGLRenderer();
				renderer.setSize( 640, 400 );
				renderer.autoClear = false;

				container.appendChild( renderer.domElement );

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				container.appendChild( stats.domElement );
			}

			function animate() {
				requestAnimationFrame( animate );
				stats.update();
				controls.update();
				render();				
			}

			var t = 0;
			function render() {

				var time = Date.now() * 0.0015;

				/*update cam & sphere positions*/

				x1 = Math.sin(t * 1.1) * 1.5;
    				y1 = Math.cos(t * 1.3) * 1.5;
   				z1 = Math.sin(t + Math.PI/3) * 1.5;
    				x2 = Math.cos(t * 1.2) * 1.5;
    				y2 = Math.sin(t * 1.4) * 1.5;
    				z2 = Math.sin(t*1.25 - Math.PI/3) * 1.5;
    				x3 = Math.cos(t * 1.15) * 1.5;
    				y3 = Math.sin(t * 1.37) * 1.5;
    				z3 = Math.sin(t*1.27) * 1.5;

				/*update uniforms*/
				
				uniforms.cameraPos.value = [camera.position.x, camera.position.y, camera.position.z];
   				uniforms.sphere1Center.value = [x1, y1, z1];
				uniforms.sphere2Center.value = [x2, y2, z2];
				uniforms.sphere3Center.value = [x3, y3, z3];

				if(camera.position.x != 0)
					console.log(camera.position);
				
				/*update attributes*/
				//--update 4 corners
				
				cLeftT = viewDirection(camera.left, camera.top, camOffset);
    				cLeftB = viewDirection(camera.left, camera.bottom, camOffset);
    				cRightT= viewDirection(camera.right, camera.top, camOffset);
    				cRightB = viewDirection(camera.right, camera.bottom, camOffset);				

				cameraTopLeft = cLeftT;
    				cameraBotLeft = cRightT;
    				cameraTopRight= cLeftB;
    				cameraBotRight= cRightB;
   		
				//--pass values to aPlotPosition attribute
				plotPos = attributes.aPlotPosition.value;
				plotPos.push(cRightT);
				plotPos.push(cLeftT);
				plotPos.push(cRightB);
				plotPos.push(cLeftB);						

				renderer.clear();

				// Render first scene into texture

				renderer.render( sceneRTT, cameraRTT, rtTexture, true );

				// Render full screen quad with generated texture

				renderer.render( sceneScreen, cameraRTT );			
			}

			function viewDirection(xLoc, yLoc, zLoc)
			{
				camera.updateMatrix;
				sceneRTT.updateMatrixWorld();
				sceneScreen.updateMatrixWorld();

				var pLocal = new THREE.Vector3(xLoc, yLoc, zLoc);				

				var worldMat = cameraRTT.matrixWorld;
				var pWorld = pLocal.applyMatrix4(worldMat);
				var dir = pWorld.sub( cameraRTT.position );

				//console.log(dir);				

				return dir;
			}

		</script>
	</body>
</html>
