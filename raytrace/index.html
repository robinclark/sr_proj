
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - render-to-texture</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #111111;
				font-family:Monospace;
				font-size:13px;
				text-align:center;
				font-weight: bold;
				background-color: #111111;
				margin: 0px;
				overflow: hidden;
			}

			#info {
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
			}

			a {
				color: #ffffff;
			}

		</style>
	</head>
	<body>

		<div id="container"></div>
		<div id="info"><a href="http://threejs.org" target="_blank">three.js</a> render-to-texture webgl example</div>

		<script src="build/three.min.js"></script>
		<script src="js/Detector.js"></script>
		<script src="js/libs/stats.min.js"></script>
		<script src="js/controls/FirstPersonControls.js"></script>
		<script src="js/controls/TrackballControls.js"></script>
		<script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>

		<!--***FRAGMENT SHADER TEXTURE***-->				      
		<script id="fragment_shader_texture" type="x-shader/x-fragment">
			precision mediump float;
			
			varying vec3 vPosition;
  			uniform vec3 cameraPos;
			
			const vec3 ambientLight = vec3(0.3, 0.3, 0.3);				
			const int NUM_LIGHTS = 1;
			const int NUM_SPHERES = 1;
			int currentShape = -1;
			float epsilon = 0.0001;

			struct PointLight
			{
				vec3 pos;
				vec3 col;
			};
			uniform PointLight lights[NUM_LIGHTS];

			//cube info
			vec3 cubeMin = vec3(-1.0, -1.0, -1.0);
			vec3 cubeMax = vec3(1.0, 1.0, 1.0);

			struct Sphere
			{
				vec3 pos;
				vec3 diffuse;				
				float reflectance;
				float transparency;
			};
			uniform Sphere spheres[NUM_SPHERES];
			
			bool intersectCube(vec3 rStart, vec3 rDir, vec3 vMin, vec3 vMax, out float dist)
			{
				dist = 10000.0;
				vec3 tMin = (vMin - rStart) / rDir;
				vec3 tMax = (vMax - rStart) / rDir;

				vec3 t1 = min(tMin, tMax);
				vec3 t2 = max(tMin, tMax);
				float tNear = max(max(t1.x, t1.y), t1.z);
				float tFar = min(min(t2.x, t2.y), t2.z);

				if(tNear < tFar)//make sure intersect along positive ray direction
				{
					
					dist = tFar;
					return true;
				}
				
				return false;
			}
			
			bool intersectSphere(vec3 pos, vec3 rStart, vec3 rDir, out float dist)
			{
				vec3 c = pos - rStart;
				float b = dot(rDir, c);
				float d = b*b - dot(c, c) + 0.125;
				if (d < 0.0) {
  					dist = 10000.0;
  					return false;
				}

    			float t1 = b - sqrt(d);
				//float t2 = b + sqrt(d);
				
				if (t1 < 0.0) {
					return false;
				}
				dist = t1;
				return true;
  			}		
			
			bool intersectScene(vec3 rStart, vec3 rDir, out vec3 pos)
			{
				float d = 10000.0;
				float newD;
				bool hit = false;
				
				if (intersectCube(rStart, rDir, cubeMin, cubeMax, newD))
				{
					hit = true;
					if(newD < d)
					{
						d = newD;
						currentShape = 0;
					}
					
				}
				
				for (int i = 0; i < NUM_SPHERES; i++)
				{
					if (intersectSphere(spheres[i].pos, rStart, rDir, newD))
					{
						hit = true;
						if (newD < d) {
							d = newD;
							currentShape = (i+1);
						}
					}	
				}
				if (hit)
				{
					pos = rStart + d * rDir;
				}				
				return hit;
			}
			
			float intersectScene(vec3 rStart, vec3 rDir)
			{
				float d = 10000.0;
				float newD;				
				
				if(intersectCube(rStart, rDir, cubeMin, cubeMax, newD))
				{
					if(newD < d)
					{
						d = newD;
					}
				}

		
				for (int i = 0; i < NUM_SPHERES; i++)
				{
					if (intersectSphere(spheres[i].pos, rStart, rDir, newD))
					{
						if (newD < d)
						{
							d = newD;
						}
					}	
				}
				
				return d;
			}
		
			//calc lighting
			vec3 colorAt(vec3 c, vec3 pos, vec3 n)
			{
				vec3 color = vec3(0.0, 0.0, 0.0);
				
				for (int i = 0; i < 1; i++) 
				{					
					vec3 lDir = (lights[i].pos - pos);
					float dist = length(lDir);					
					lDir = normalize(lDir);
					float lamb = dot(n, lDir);					

					//cull possible intersections if normals in diff dir's
					if ( lamb <= 0.0 )
					{
						continue;
					}
					//if position obstructed from light
					if(intersectScene((pos + .01*n), lDir) < dist)
					{
						continue;
					}			
					
					//calc color					
					color += c * lights[i].col * lamb;
				}
				//add ambient light			
				color += ambientLight * c;
				return color;
			}
			
			vec3 refrDir(float n1, float n2, vec3 norm, vec3 i)
			{
				float n = n1/n2;
				float cosI = dot(-i, norm);
				float sin2T = n * n * ( 1.0 - cosI * cosI);
				if (sin2T > 1.0)//total internal reflection
				{
					return vec3(0.0, 0.0, 0.0);
				}
				float cosT = sqrt(1.0 - sin2T);
				return n * i + (n * cosI - cosT) * norm;
			}
			
			float fresnel(float n1, float n2, vec3 norm, vec3 i)//schlick's approx
			{
				float ref = (n1-n2)/(n1+n2);
				ref *= ref;
				float cosX = dot(-i, norm);
				if (n1 > n2)
				{
					float n = n1/n2;
					float sin2T = n * n * (1.0-cosX * cosX);
					if (sin2T > 1.0)
					{
						return 1.0;
					}
					cosX = sqrt(1.0-sin2T);
				}
				float x = 1.0-cosX;
				return ref + (1.0-ref) * x * x * x * x * x;
			}

			vec3 cubeNormal(vec3 p, vec3 cMin, vec3 cMax)
			{

					 if(p.x < (cMin.x + epsilon)) return vec3(-1.0, 0.0, 0.0);
				else if(p.x > (cMax.x - epsilon)) return vec3(1.0, 0.0, 0.0);
				else if(p.y < (cMin.y + epsilon)) return vec3(0.0, -1.0, 0.0);
				else if(p.y > (cMax.y - epsilon)) return vec3(0.0, 1.0,  0.0);
				else if(p.z < (cMin.z + epsilon)) return vec3(0.0, 0.0, -1.0);
				else return vec3(0.0, 0.0, 1.0);
			}

			vec3 cubeColor(vec3 p)
			{
				if(p.x > 0.9999)
				{
					return vec3(0.63, 0.06, 0.04);
				}
				else if(p.x < -0.9999)
				{
					return vec3(0.15, 0.48, 0.09);
				}
				else
				{
					return vec3(0.76, 0.75, 0.5);
				}
			}
			
			vec3 getColor(int shape, vec3 pos, out vec3 norm)
			{
				vec3 n, c;
				if(shape == 0)//cube
				{
					n = -cubeNormal(pos, cubeMin, cubeMax);
					c = cubeColor(pos);
				}
				else if(shape > 0)//spheres
				{
					for(int i = 0; i < NUM_SPHERES; i++)
					{
						if(shape == (i+1))
						{
							n = normalize(pos - spheres[i].pos);
							c = spheres[i].diffuse;
						}
					}
				}
				else
				{
					norm = vec3(0.0, 0.0, 0.0);
					return norm;
				}

				norm = n;
				return colorAt(c, pos, n);
			}

  			void main(void)
  			{
  				//calc ray dir
				vec3 cameraDir = normalize(vPosition - cameraPos);

				//determine intersect
				vec3 sP;
				bool hit = false;				
				hit = intersectScene(cameraPos, cameraDir, sP);
				
				if (hit)
				{					
					vec3 sN, sC = vec3(0.0, 0.0, 0.0), reflC = vec3(0.0, 0.0,0.0), refrC = vec3(0.0, 0.0, 0.0);
					sC = getColor(currentShape, sP, sN);
					
					for(int i = 0; i < NUM_SPHERES; i++)
					{
						if(currentShape == (i+1))
						{
							if(spheres[i].reflectance > 0.0)
							{
								//store current shape
								int tempShape = currentShape;
								vec3 rN, reflP, reflD = reflect(cameraDir, sN);
								if(intersectScene(sP + 0.01*sN, reflD, reflP))
								{
									reflC = getColor(currentShape, reflP, rN);
								}
								currentShape = tempShape;
							}
							if(spheres[i].transparency > 0.0)
							{
								vec3 refrD, refrP;
								//get refraction dir
								refrD = refrDir(1.0, 1.33, sN, cameraDir);

								//store current shape
								int tempShape = currentShape;
								if(intersectScene(sP - 0.01*sN, refrD, refrP))
								{
									//get normal
									vec3 rN = -(refrP - spheres[i].pos);//getcolor() vs calculating directly? which faster

									//second refraction
									refrD = refrDir(1.0, 1.33, rN, cameraDir);

									//store current shape
									int tempShape = currentShape;
									if(intersectScene(refrP - 0.01*rN, refrD, refrP))//using same var ok?
									{
										refrC = getColor(currentShape, refrP, rN);
									}
									currentShape = tempShape;
								}
								currentShape = tempShape;
							}
						}
					}			
					/*vec3 tN, tC;
					vec3 refrD2, refrP2;
					//refraction color
					if (surfShape.transparency > 0.0)
					{
						//1st intersection
						refrD = refrDir(1.0, 1.33, sN, cameraDir);						
						if(intersectScene(sPos - 0.01*sN, refrD, refrP))
						{
							refrShape = currentShape;
							if(refrShape.type == SPHERE)
							{
								tN = -1.0*normalize(refrP - refrShape.pos);
							}
							if(refrShape.type == PLANE)
							{
								tN = -1.0*refrShape.norm;
							}
							
							//2nd intersection
							//--reset tC
							tC = vec3(0.0, 0.0, 0.0);
							refrD2 = refrDir(1.33, 1.0, tN, refrD);
							if(intersectScene(refrP - 0.01*tN, refrD2, refrP2))
							{
								refrShape = currentShape;
								if(refrShape.type == SPHERE)
								{
									tN = normalize(refrP2 - refrShape.pos);
								}
								if(refrShape.type == PLANE)
								{
									tN = refrShape.norm;
								}
								tC = refrShape.diffuse;
								refrC = colorAt(tC, refrP2, tN);
							}
						}
					}*/
					
					//float fresnel(float n1, float n2, vec3 norm, vec3 i)//schlick's approx
					//float f = fresnel(1.0, 1.33, sN, cameraDir);
					//vec3 finalC = (f*reflC*surfShape.reflectance + (1.0-f)*refrC*surfShape.transparency) + surfC;
					currentShape = -1;
					gl_FragColor = vec4(refrC, 1.0);
				 	//gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
				}
				else
				{
      					gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
    			}
 			}
		</script>
		
		<!--***VERTEX SHADER TEXTURE***-->
		<script id="vertex_shader_texture" type="x-shader/x-vertex">

			attribute vec3 aPlotPosition;

			varying vec3 vPosition;

			void main() {
				vPosition =  aPlotPosition;
				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			}

		</script>

		<!--***FRAGMENT SHADER SCREEN***-->
		<script id="fragment_shader_screen" type="x-shader/x-fragment">

			varying vec2 vUv;

			uniform sampler2D tDiffuse;

			void main() {
				gl_FragColor = texture2D( tDiffuse, vUv );
			}

		</script>

		<!--***VERTEX SHADER SCREEN***-->
		<script id="vertex_shader_screen" type="x-shader/x-vertex">

			varying vec2 vUv;

			void main() {
				vUv = uv;
				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			}

		</script>

		<script>

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var container, stats;

			var cameraRTT, sceneRTT, sceneScreen, renderer, scene, camera;

			var uniforms, attributes, controls;

			var ratio = 1.6

			var w = 3.2;
			var h = 2;
			
			var camOffset = -.5;
			
			//var wWidth = window.innerWidth;
			//var wHeight = window.innerHeight;			

			var rtTexture, material, quad;

			var delta = 0.01;

			var SPHERE = 0, PLANE = 1;

			var mesh1, mesh2;

			var lookDir; 
			
			var origin;
			var up;

			var t = 0;
			var center;			
			var plotPos;
			var attributes;

			init();
			animate();

			function init() {
				container = document.getElementById( 'container' );

				renderer = new THREE.WebGLRenderer();
				renderer.setSize( 640, 400 );
				renderer.autoClear = false;

				container.appendChild( renderer.domElement );

				lookDir = {x: 0, y: 0, z: 0};
				camUp = {x: 0, y: 1, z: 0};
				origin = {x: 0, y: 0, z: 0};			
				center = {x: 0, y: 0, z: 0};				
				
				//camera
				cameraRTT = new THREE.OrthographicCamera( w / - 2, w / 2, h  / 2, h / - 2, -10000, 10000 );
				cameraRTT.position.z = 20;
				
				/*moving camera*/
				camera = new THREE.OrthographicCamera( w / - 2, w / 2, h  / 2, h / - 2, -10000, 10000 );
				camera.position.z = 15;
				
				//controls
				controls = new THREE.TrackballControls( camera, renderer.domElement );

				//scenes
				sceneRTT = new THREE.Scene();
				sceneScreen = new THREE.Scene();

				//txtre to render to
				rtTexture = new THREE.WebGLRenderTarget( 512, 512, { minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter, format: THREE.RGBFormat } );				
				
				/*struct Sphere
				{
				vec3 pos;
				vec3 diffuse;				
				float reflectance;
				float transparency;
				}*/		
				
				uniforms =
				{					
					//sphere1
					"spheres[0].pos": {
						type: 'fv',
						value: [0, 0, 0]
					},
					"spheres[0].diffuse": {
						type: 'fv',
						value: [0.76, 0.75, 0.5]
					},
					"spheres[0].reflectance": {
						type: 'f',
						value: 0.0
					},					
					"spheres[0].transparency": {
						type: 'f',
						value: 1.0
					},
					//--lights
					"lights[0].pos": {
						type: 'fv',
						value: [0, .8, 0]
					},
					"lights[0].col": {
						type: 'fv',
						value: [1.0, 1.0, 1.0]
					},
					"lights[1].pos": {
						type: 'fv',
						value: [-10.0, 0.0, 0.0]
					},
					"lights[1].col": {
						type: 'fv',
						value: [1.0, 1.0, 1.0]
					},
					/**********************************************************/
					cameraPos: {
						type: 'fv', // vec3
						value: [0, 0, 0]
					},
				};			

				attributes = {
					aPlotPosition: {
						type : 'v3',
						value : []
					},
				}
				
				plotPos = attributes.aPlotPosition.value;
				for (var i = 0; i < 4; i++) {
					plotPos[i] = 0;
				}

				material = new THREE.ShaderMaterial( {
					uniforms: uniforms,
					attributes: attributes,
					vertexShader: document.getElementById( 'vertex_shader_texture' ).textContent,
					fragmentShader: document.getElementById( 'fragment_shader_texture' ).textContent
				} );

				var materialScreen = new THREE.ShaderMaterial( {
					uniforms: { tDiffuse: { type: "t", value: rtTexture } },
					vertexShader: document.getElementById( 'vertex_shader_screen' ).textContent,
					fragmentShader: document.getElementById( 'fragment_shader_screen' ).textContent,
					depthWrite: false
				} );

				var plane = new THREE.PlaneGeometry( w, h);

				quad = new THREE.Mesh( plane, material );
				quad.position.z = 0;
				sceneRTT.add( quad );

				quad = new THREE.Mesh( plane, materialScreen );
				quad.position.z = 0;
				sceneScreen.add( quad );
				
				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				container.appendChild( stats.domElement );
			}

			function animate() {

				requestAnimationFrame( animate );
				stats.update();
				controls.update();
				render();				
			}						

			function render() {
				camera.updateMatrixWorld();
				camera.matrixWorldInverse.getInverse(camera.matrixWorld);			
		
				/*update attributes*/
				//--update 4 corners				
   				camP = { 
					x: camera.position.x,
					y: camera.position.y,
					z: camera.position.z,
				};		
			
				var offset = 2.0;
				lookDir = normalize(vectSub(origin, camP));
				camRight = normalize(crossProd(lookDir, camUp));
				up = normalize(crossProd(camRight, lookDir));
				center = vectAdd(camP, vectMul(lookDir, offset));
				uR = vectAdd(vectAdd(center, up), vectMul(camRight, ratio));
				bR = vectAdd(vectSub(center, up), vectMul(camRight, ratio));
				uL = vectSub(vectAdd(center, up), vectMul(camRight, ratio));
				bL = vectSub(vectSub(center, up), vectMul(camRight, ratio));	
				
				uniforms.cameraPos.value = [camP.x, camP.y, camP.z];
				
				attributes.aPlotPosition.value[0] = uL;
				attributes.aPlotPosition.value[1] = uR;
				attributes.aPlotPosition.value[2] = bL;
				attributes.aPlotPosition.value[3] = bR;
				
				attributes.aPlotPosition.needsUpdate = true;

				renderer.clear();

				// Render first scene into texture

				// renderer.render( sceneRTT, cameraRTT, rtTexture, true );
			
				// Render full screen quad with generated texture
				
				//render in center
				/*var left, bottom;
				left = wWidth/2.0;
				bottom = wHeight/2.0;
				renderer.setViewport( 100, 200, 640, 400 );
				//renderer.setScissor(left, bottom, 640, 400);
				//renderer.enableScissorTest ( true )*/

				renderer.render( sceneRTT, cameraRTT );		
				//renderer.render(scene, camera);	  
			}

			function viewDirection(xLoc, yLoc, zLoc)
			{
				camera.updateMatrixWorld();
				var pLocal = new THREE.Vector3(xLoc, yLoc, zLoc);	
				var worldMat = camera.matrixWorld;
				var pWorld = pLocal.applyMatrix4(worldMat);
				var dir = pWorld.sub( camera.position );			

				return dir;
			}

			function crossProd(v1, v2) {
    				return {x: v1.y*v2.z - v2.y*v1.z,
            			 y: v1.z*v2.x - v2.z*v1.x,
             			z: v1.x*v2.y - v2.x*v1.y };
  			}

  			function normalize(v) {
				l = Math.sqrt(v.x*v.x + v.y*v.y + v.z*v.z);
				return { x: v.x/l, y: v.y/l, z: v.z/l };
			}

			function vectAdd(v1, v2) {
				return { x: v1.x + v2.x, y: v1.y + v2.y, z: v1.z + v2.z };
			}
		      
			function vectSub(v1, v2) {
				return { x: v1.x - v2.x, y: v1.y - v2.y, z: v1.z - v2.z };
			}	
		      
			function vectMul(v, l) {
				return { x: v.x*l, y: v.y*l, z: v.z*l };
			}
			
			function distance(v1, v2) {
				return Math.sqrt((v1.x-v2.x)*(v1.x-v2.x) + (v1.y-v2.y)*(v1.y-v2.y) + (v1.z-v2.z)*(v1.z-v2.z));
			}
		</script>
	</body>
</html>
