
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - render-to-texture</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #111111;
				font-family:Monospace;
				font-size:13px;
				text-align:center;
				font-weight: bold;
				background-color: #111111;
				margin: 0px;
				overflow: hidden;
			}

			#info {
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
			}

			a {
				color: #ffffff;
			}

		</style>
	</head>
	<body>

		<div id="container"></div>
		<div id="info"><a href="http://threejs.org" target="_blank">three.js</a> render-to-texture webgl example</div>

		<script src="build/three.min.js"></script>
		<script src="js/Detector.js"></script>
		<script src="js/libs/stats.min.js"></script>
		<script src="js/controls/FirstPersonControls.js"></script>
		<script src="js/controls/TrackballControls.js"></script>

		<!--***FRAGMENT SHADER TEXTURE***-->				      
		<script id="fragment_shader_texture" type="x-shader/x-fragment">
			precision mediump float;

			//bool intersectTriangle(vec3 v[3], vec3 lStart, vec3 lDir, vec3 n, out float dist);

  			const vec3 lightDir = vec3(0.577350269, 0.577350269, -0.577350269);

			varying vec3 vPosition;

  			uniform vec3 cameraPos;
  			uniform vec3 sphere1Center;
  			uniform vec3 sphere2Center;
  			uniform vec3 sphere3Center;

			struct Cube
			{
				vec3 v[8];
				vec3 n[6];
				vec3 c[6];
			};

			Cube cube1;

			bool intersectCube(Cube c, vec3 lStart, vec3 lDir, out float dist)
			{
				//check for intersect at each cube face
				//vec3 t1[3] = vec3[](	
				//		vec3(1.0, 1.0, 1.0), 
				//		vec3(1.0, 1.0, 1.0), 
				//		vec3(1.0, 1.0, 1.0)
				//	     );
				
				/*vec3 t1[8];
				for(int i = 0; i < 8; i++)
				{
					t
				}*/
			
				//intersectTriangle(
				

				return true;
			}

			struct Shape
			{
				int type;
				vec3 position;				
				vec3 color;
				float size;
				vec3 normal;
			};

			uniform Shape plane;

			struct Triangle
			{
				vec3 coords[3];
			};

			uniform Triangle t;

			vec3 getTriNormal(Triangle t)
			{
				vec3 a = t.coords[0] - t.coords[1];
				vec3 b = t.coords[2] - t.coords[1];
				vec3 r = normalize(cross(a,b));
				
				return r;
			}

			bool intersectTriangle(vec3 v[3], vec3 lStart, vec3 lDir, vec3 n, out float dist)
			{
				/*//ray dir
				vec3 l = lDir;
				
				//ray origin
				vec3 l0 = lStart;

				dist = 0.0;

				float denom = dot(l, n);
				if(denom == 0.0)
				{
					dist = 10000.0;
					return false;
				}
				
				float num = dot((v[0] - l0), n);
				dist = num/denom;

				vec3 p = l0+l*dist;
				vec3 v0 = v[2]-v[0];
				vec3 v1 = v[1]-v[0];
				vec3 v2 = p-v[0];

				float dot00 = dot(v0, v0);
				float dot01 = dot(v0, v1);
				float dot02 = dot(v0, v2);
				float dot11 = dot(v1, v1);
				float dot12 = dot(v1, v2);

				float dnomInv = 1.0/(dot00 * dot11 - dot01 * dot01);	
				float u = (dot11 * dot02 - dot01 * dot12) * dnomInv;
				float v = (dot00 * dot12 - dot01 * dot02) * dnomInv;

				if(u >= 0.0 && v >= 0.0 && (u+v) < 1.0) //point within triangle
				{
					return true;
				}*/

				return false;							
			}

			bool intersectPlane(vec3 center, vec3 lStart, vec3 lDir, vec3 n, out float dist)
			{
				//ray dir
				vec3 l = lDir;
				
				//ray origin
				vec3 l0 = lStart;
				
				//plane origin
				vec3 p0 = center;

				dist = 0.0;

				float denom = dot(l, n);
				if(denom == 0.0) return false;
				
				float num = dot((p0 - l0), n);
				dist = num/denom;

				vec3 dP = p0 - (dist*l + l0);
				float size = plane.size;
				if(abs(dP.x) > size || abs(dP.y) > size)
				{
					return false;
				}

    				return true;
			}

			

 			bool intersectSphere(vec3 center, vec3 lStart, vec3 lDir, out float dist)
			{
    				vec3 c = center - lStart;
    				float b = dot(lDir, c);
    				float d = b*b - dot(c, c) + 1.0;
    				if (d < 0.0) {
      					dist = 10000.0;
      					return false;
    				}

    				dist = b - sqrt(d);
    				if (dist < 0.0) {
      					dist = 10000.0;
      					return false;
    				}

    				return true;
  			}

  			vec3 lightAt(vec3 N, vec3 V, vec3 color)
			{
    				vec3 L = lightDir;
    				vec3 R = reflect(-L, N);

    				float c = 0.3 + 0.4 * pow(max(dot(R, V), 0.0), 30.0) + 0.7 * dot(L, N);

    				if (c > 1.0) {
      					return mix(color, vec3(1.6, 1.6, 1.6), c - 1.0);
    				}

    				return c * color;
				//return color;
  			}

  			bool intersectWorld(vec3 lStart, vec3 lDir, out vec3 pos, out vec3 normal, out vec3 color)
			{
    				float d1, d2, d3, d4;
    				bool h1, h2, h3, h4;

    				h1 = intersectSphere(sphere1Center, lStart, lDir, d1);
    				h2 = intersectSphere(sphere2Center, lStart, lDir, d2);
    				h3 = intersectSphere(sphere3Center, lStart, lDir, d3);

				vec3 pC = plane.position;
				vec3 pN = plane.normal;
				//h4 = intersectPlane(pC, lStart, lDir, pN, d4);
				
				/*vec3 triN = getTriNormal(t);
				h4 = intersectTriangle(t, lStart, lDir, triN, d4);

				if(h4 && d4 < d1 && d4 < d2 && d4 < d3)
				{
					pos = lStart + d4 * lDir;
					normal = triN;
					color = plane.color;
				}
    				else*/ if (h1 && d1 < d2 && d1 < d3)
				{
      					pos = lStart + d1 * lDir;
      					normal = pos - sphere1Center;
      					color = vec3(0.0, 0.0, 0.9);
    				}
    				else if (h2 && d2 < d3)
				{
      					pos = lStart + d2 * lDir;
      					normal = pos - sphere2Center;
      					color = vec3(0.9, 0.0, 0.0);
    				}
    				else if (h3) {
      					pos = lStart + d3 * lDir;
      					normal = pos - sphere3Center;
      					color = vec3(0.0, 0.9, 0.0);
    				}
    				else if (lDir.y < -0.01)
				{
     					pos = lStart + ((lStart.y + 2.7) / -lDir.y) * lDir;
      					if (pos.x*pos.x + pos.z*pos.z > 30.0)
					{
        					return false;
      					}

      					normal = vec3(0.0, 1.0, 0.0);

      					if (fract(pos.x / 5.0) > 0.5 == fract(pos.z / 5.0) > 0.5)
					{
        					color = vec3(1.0);
      					}
      					else
					{
        					color = vec3(0.0);
      					}
    				}
    				else
				{
     					return false;
    				}

    				return true;
  			}

  			void main(void)
  			{
    				vec3 cameraDir = normalize(vPosition - cameraPos);

    				vec3 p1, norm, p2;
    				vec3 col, colT, colM, col3;
   				if (intersectWorld(cameraPos, cameraDir, p1, norm, colT))
				{
      					col = lightAt(norm, -cameraDir, colT);
      					colM = (colT + vec3(0.7)) / 1.7;
      					cameraDir = reflect(cameraDir, norm);
      					if (intersectWorld(p1, cameraDir, p2, norm, colT))
					{
        					col += lightAt(norm, -cameraDir, colT) * colM;
        					colM *= (colT + vec3(0.7)) / 1.7;
        					cameraDir = reflect(cameraDir, norm);
        					if (intersectWorld(p2, cameraDir, p1, norm, colT))
						{
          						col += lightAt(norm, -cameraDir, colT) * colM;
        					}
      					}

      					gl_FragColor = vec4(col, 1.0);
    				}
    				else
				{
      					gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
    				}
 			}

		</script>

		<!--***VERTEX SHADER TEXTURE***-->
		<script id="vertex_shader_texture" type="x-shader/x-vertex">

			attribute vec3 aPlotPosition;

			varying vec3 vPosition;

			void main() {
				vPosition =  aPlotPosition;
				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				//gl_Position = vec4(aPlotPosition,1);
			}

		</script>

		<!--***FRAGMENT SHADER SCREEN***-->
		<script id="fragment_shader_screen" type="x-shader/x-fragment">

			varying vec2 vUv;

			uniform sampler2D tDiffuse;

			void main() {
				gl_FragColor = texture2D( tDiffuse, vUv );
			}

		</script>

		<!--***VERTEX SHADER SCREEN***-->
		<script id="vertex_shader_screen" type="x-shader/x-vertex">

			varying vec2 vUv;

			void main() {
				vUv = uv;
				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			}

		</script>

		<script>

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var container, stats;

			var cameraRTT, sceneRTT, sceneScreen, renderer, scene, camera;

			var uniforms, attributes, controls;

			var ratio = 1.6

			var w = 3.2;
			var h = 2;
			
			var camOffset = -5;
			
			var wWidth = window.innerWidth;
			var wHeight = window.innerHeight;			

			var rtTexture, material, quad;

			var delta = 0.01;

			var PLANE = 1, SPHERE = 0;

			var mesh1, mesh2;
	
			var dUL, dUR, dBL, dBR;

			var uL, bL, uR, bR;
			
			var camC, camD, center;
			var camLeft, camRight, camDown;

			var lookDir; 
			var camP;
			var camUp;
			var x, y, z;
			var x1, y1, z1;
			var origin;
			var up;
			var s1;
			var pos;

			var cubeVtx;
			var cubeMat;
			var cubeCol;
			var cubeNorm;

			var mouseDown = false;
   			var lastMouseX = null;
    			var lastMouseY = null;
			var camRotationMatrix;
			var rotX;
			var rotY;
			//var newRotationMatrix;
			var cPos;
			var cPosL;
			var startPos;

			init();
			animate();

			function init() {
				container = document.getElementById( 'container' );
				container.onmousedown = handleMouseDown;
        			container.onmouseup = handleMouseUp;
        			document.onmousemove = handleMouseMove;

				renderer = new THREE.WebGLRenderer();
				renderer.setSize( 640, 400 );
				renderer.autoClear = false;

				container.appendChild( renderer.domElement );

				lookDir = {x: 0, y: 0, z: 0};
				camUp = {x: 0, y: 1, z: 0};
				camP = {x: 0, y: 0, z: 0};
				origin = {x: 0, y: 0, z: 0};			
				center = {x: 0, y: 0, z: 0};
				
				//cube info
				cubeVtx = [[1, 1, -1], [-1, 1, -1], [1, 1, 1], [-1, 1, 1], [1, -1, -1], [-1, -1, -1], [1, -1, 1], [1, -1, 1]];
				cubeCol = [[1, 0, 0], [1, 0, 0], [1, 0, 0], [1, 0, 0], [1, 0, 0], [1, 0, 0]];
				cubeNorm = [[0, 1, 0], [0, -1, 0], [-1, 0, 0], [0, 0, -1], [1, 0, 0], [0, 0, 1]];
				cubeMat = new THREE.Matrix4();

				//mouse movement
				camRotationMatrix = new THREE.Matrix4();
				cPos = new THREE.Vector3();
				startPos = new THREE.Vector3(0, 0, 20);
				cPos.copy(startPos);
				
				//camera
				cameraRTT = new THREE.OrthographicCamera( w / - 2, w / 2, h  / 2, h / - 2, -10000, 10000 );
				cameraRTT.position.z = 20;

				
				/*moving camera*/
				camera = new THREE.OrthographicCamera( w / - 2, w / 2, h  / 2, h / - 2, -10000, 10000 );
				camera.position.z = 20;
				
				//controls
				//controls = new THREE.TrackballControls( camera, renderer.domElement );

				/*controls.rotateSpeed = 1.0;
				controls.zoomSpeed = 1.2;
				controls.panSpeed = 0.8;

				controls.noZoom = false;
				controls.noPan = false;

				controls.staticMoving = true;
				controls.dynamicDampingFactor = 0.3;

				controls.addEventListener( 'change', render );	*/

				//scenes
				sceneRTT = new THREE.Scene();
				sceneScreen = new THREE.Scene();

				//txtre to render to
				rtTexture = new THREE.WebGLRenderTarget( 512, 512, { minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter, format: THREE.RGBFormat } );
				
				uniforms = {
					
					/**********************************************************/
					//--plane
					"plane.type": {
						type: 'i', // int
						value: 1
					},
					"plane.position": {
						type: 'fv', // vec3
						value: [0, 0, -20]
					},
					"plane.color": {
						type: 'fv', // vec3
						value: [1, 1, 0]
					},
					"plane.size": {
						type: 'f', // float
						value: 3.0
					},
					"plane.normal": {
						type: 'fv', // vec3
						value: [0,0,-1]
					},
					/**********************************************************/
					//--triangle
					/*"t.coords[0]": {
						type: 'fv', // vec3
						value: [0, 0, 0]
					},
					"t.coords[1]": {
						type: 'fv', // vec3
						value: [-2, -1, 0]
					},
					"t.coords[2]": {
						type: 'fv', // vec3
						value: [2, -1, 0]
					},			*/
					/**********************************************************/
					//--cube
					//verts
					"cube1.v[0]": {
						type: 'fv',
						value: cubeVtx[0],
					},
					"cube1.v[1]": {
						type: 'fv',
						value: cubeVtx[1],
					},
					"cube1.v[2]": {
						type: 'fv',
						value: cubeVtx[2],
					},
					"cube1.v[3]": {
						type: 'fv',
						value: cubeVtx[3],
					},
					"cube1.v[4]": {
						type: 'fv',
						value: cubeVtx[4],
					},
					"cube1.v[5]": {
						type: 'fv',
						value: cubeVtx[5],
					},
					"cube1.v[6]": {
						type: 'fv',
						value: cubeVtx[6],
					},
					"cube1.v[7]": {
						type: 'fv',
						value: cubeVtx[7],
					},

					//colors
					"cube1.c[0]": {
						type: 'fv',
						value: cubeCol[0],
					},
					"cube1.c[1]": {
						type: 'fv',
						value: cubeCol[1],
					},
					"cube1.c[2]": {
						type: 'fv',
						value: cubeCol[2],
					},
					"cube1.c[3]": {
						type: 'fv',
						value: cubeCol[3],
					},
					"cube1.c[4]": {
						type: 'fv',
						value: cubeCol[4],
					},
					"cube1.c[5]": {
						type: 'fv',
						value: cubeCol[5],
					},				
					
					//norms
					"cube1.n[0]": {
						type: 'fv',
						value: cubeNorm[0],
					},
					"cube1.n[1]": {
						type: 'fv',
						value: cubeNorm[1],
					},
					"cube1.n[2]": {
						type: 'fv',
						value: cubeNorm[2],
					},
					"cube1.n[3]": {
						type: 'fv',
						value: cubeNorm[3],
					},
					"cube1.n[4]": {
						type: 'fv',
						value: cubeNorm[4],
					},
					"cube1.n[5]": {
						type: 'fv',
						value: cubeNorm[5],
					},	
					/**********************************************************/
					cameraPos: {
						type: 'fv', // vec3
						value: [0, 0, 0]
					},
					sphere1Center: {
						type: 'fv', // vec3
						value: [0, 0, 0]
					},
					sphere2Center: {
						type: 'fv', // vec3
						value: [0, 0, 0]
					},
					sphere3Center: {
						type: 'fv', // vec3
						value: [0, 0, 0]
					},
					/**********************************************************/
					
				};			

				attributes = {
					aPlotPosition: {
						type : 'v3',
						value : []
					},
				}	

				material = new THREE.ShaderMaterial( {
					uniforms: uniforms,
					attributes: attributes,
					vertexShader: document.getElementById( 'vertex_shader_texture' ).textContent,
					fragmentShader: document.getElementById( 'fragment_shader_texture' ).textContent
				} );

				var materialScreen = new THREE.ShaderMaterial( {
					uniforms: { tDiffuse: { type: "t", value: rtTexture } },
					vertexShader: document.getElementById( 'vertex_shader_screen' ).textContent,
					fragmentShader: document.getElementById( 'fragment_shader_screen' ).textContent,
					depthWrite: false
				} );

				var plane = new THREE.PlaneGeometry( w, h);

				quad = new THREE.Mesh( plane, material );
				quad.position.z = 0;
				sceneRTT.add( quad );

				quad = new THREE.Mesh( plane, materialScreen );
				quad.position.z = 0;
				sceneScreen.add( quad );
				
				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				container.appendChild( stats.domElement );
			}

			function animate() {

				requestAnimationFrame( animate );
				stats.update();
				//controls.update();
				render();				
			}

			var t = 0;
			function render() {
				camera.updateMatrixWorld();
				camera.matrixWorldInverse.getInverse(camera.matrixWorld);			

				var time = Date.now() * 0.0015;

				/*camC.copy(lookDir);
				camC.multiplyScalar(20);
				camC.add(camera.position);
				uniforms["t.coords[0]"].value = [camC.x, camC.y, camC.z];
				uniforms["t.coords[1]"].value = [-(camera.position.x-0.5), (camera.position.y-1.0), camera.position.z-15.0];	
				uniforms["t.coords[2]"].value = [-(camera.position.x+0.5), (camera.position.y-1.0), camera.position.z-15.0];*/

				/*update attributes*/
				//--update 4 corners
				
				cLeftT = viewDirection(camera.left, camera.top, camOffset);
    				cLeftB = viewDirection(camera.left, camera.bottom, camOffset);
    				cRightT= viewDirection(camera.right, camera.top, camOffset);
    				cRightB = viewDirection(camera.right, camera.bottom, camOffset);

				cLeftT.add(camera.position);
				cLeftB.add(camera.position);
				cRightT.add(camera.position);
				cRightB.add(camera.position);

				dUL = cLeftT.distanceTo(camera.position);
				dUR = cRightT.distanceTo(camera.position);
				dBL = cLeftB.distanceTo(camera.position);
				dBR = cRightB.distanceTo(camera.position);

				//--calc corners								
				camP.x = cPos.x;
				camP.y = cPos.y;
				camP.z = cPos.z;			
			
				var offset = 6;
				lookDir = normalize(vectSub(origin, camP));
				camRight = normalize(crossProd(lookDir, camUp));
				up = normalize(crossProd(camRight, lookDir));
				center = vectAdd(camP, vectMul(lookDir, offset));
				uR = vectAdd(vectAdd(center, up), vectMul(camRight, ratio));
				bR = vectAdd(vectSub(center, up), vectMul(camRight, ratio));
				uL = vectSub(vectAdd(center, up), vectMul(camRight, ratio));
				bL = vectSub(vectSub(center, up), vectMul(camRight, ratio));
				
				//--pass values to aPlotPosition attribute
				var plotPos = attributes.aPlotPosition.value;
	
				/*plotPos[0] = cLeftT;
				plotPos[1] = cRightT;
				plotPos[2] = cLeftB;
				plotPos[3] = cRightB;*/

				uniforms.cameraPos.value = [camP.x, camP.y, camP.z];
				plotPos[0] = uL;
				plotPos[1] = uR;
				plotPos[2] = bL;
				plotPos[3] = bR;

				
				

				renderer.clear();

				// Render first scene into texture

				//renderer.render( sceneRTT, cameraRTT, rtTexture, true );
			
				// Render full screen quad with generated texture

				renderer.render( sceneRTT, cameraRTT );		
				//renderer.render(scene, camera);	   	

				t += 0.03;
    				if (t > Math.PI * 200) {
      					t -= Math.PI * 200;
   				}

			}

			function viewDirection(xLoc, yLoc, zLoc)
			{
				camera.updateMatrixWorld();
				var pLocal = new THREE.Vector3(xLoc, yLoc, zLoc);	
				var worldMat = camera.matrixWorld;
				var pWorld = pLocal.applyMatrix4(worldMat);
				var dir = pWorld.sub( camera.position );			

				return dir;
			}

			function crossProd(v1, v2) {
    				return {x: v1.y*v2.z - v2.y*v1.z,
            			 y: v1.z*v2.x - v2.z*v1.x,
             			z: v1.x*v2.y - v2.x*v1.y };
  			}

  			function normalize(v) {
   			l = Math.sqrt(v.x*v.x + v.y*v.y + v.z*v.z);
    return { x: v.x/l, y: v.y/l, z: v.z/l };
  }

  function vectAdd(v1, v2) {
    return { x: v1.x + v2.x, y: v1.y + v2.y, z: v1.z + v2.z };
  }

  function vectSub(v1, v2) {
    return { x: v1.x - v2.x, y: v1.y - v2.y, z: v1.z - v2.z };
  }

  function vectMul(v, l) {
    return { x: v.x*l, y: v.y*l, z: v.z*l };
  }

	    function degToRad(degrees) {
        return degrees * Math.PI / 180;
    }

     function handleMouseDown(event) {
        mouseDown = true;
        lastMouseX = event.clientX;
        lastMouseY = event.clientY;
	
	//alert("mouse down");
     }

    function handleMouseUp(event) {
        mouseDown = false;
	//alert("mouse up");
    }
	
	function handleMouseMove(event) {
       /* if (!mouseDown) {
            return;
        }
        var newX = event.clientX;
        var newY = event.clientY;

        var deltaX = newX - lastMouseX
        var newRotationMatrix = mat4.create();
        mat4.identity(newRotationMatrix);
        mat4.rotate(newRotationMatrix, degToRad(deltaX / 10), [0, 1, 0]);

        var deltaY = newY - lastMouseY;
        mat4.rotate(newRotationMatrix, degToRad(deltaY / 10), [1, 0, 0]);

        mat4.multiply(newRotationMatrix, moonRotationMatrix, moonRotationMatrix);

        lastMouseX = newX
        lastMouseY = newY;
      */

	if (!mouseDown) {
            return;
        }
        var newX = event.clientX;
        var newY = event.clientY;

        var deltaX = newX - lastMouseX;
        var rotMatrixX = new THREE.Matrix4();
        var rotMatrixY = new THREE.Matrix4();
	var rotMatrixXY = new THREE.Matrix4();

        //mat4.rotate(newRotationMatrix, degToRad(deltaX / 10), [0, 1, 0]);
	rotX = degToRad(deltaX / 10);
	rotMatrixY.makeRotationY(rotX);

        var deltaY = newY - lastMouseY;
        //mat4.rotate(newRotationMatrix, degToRad(deltaY / 10), [1, 0, 0]);
	rotY = degToRad(deltaY / 10);
	rotMatrixX.makeRotationX(rotY);	

        //mat4.multiply(newRotationMatrix, moonRotationMatrix, moonRotationMatrix);
	rotMatrixXY.multiplyMatrices(rotMatrixX, rotMatrixY);

	camRotationMatrix.multiply(rotMatrixXY);

        lastMouseX = newX
        lastMouseY = newY;	

	cPos.copy(startPos);
	cPos.applyMatrix4(camRotationMatrix);

	//alert("mouse move");
    }

		</script>
	</body>
</html>
